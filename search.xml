<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>“python-eggies”</title>
    <url>/2019/12/06/%E2%80%9Cpython-eggies%E2%80%9D/</url>
    <content><![CDATA[<h1 id="python-eggies"><a href="#python-eggies" class="headerlink" title="python eggies"></a>python eggies</h1><h2 id="overload-in-python"><a href="#overload-in-python" class="headerlink" title="overload in python"></a>overload in python</h2><p>Actually, there is no function overload in python,but we can do it in a different way</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roll_dice</span><span class="params">(n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    total=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):	 <span class="comment">#change range() to unary</span></span><br><span class="line">        total+=randint(<span class="number">1</span>,<span class="number">6</span>) <span class="comment">#use _ as default</span></span><br><span class="line">    <span class="keyword">return</span> total		<span class="comment">#loop n times</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br><span class="line"></span><br><span class="line">print(roll_dice())    <span class="comment">#default</span></span><br><span class="line">print(roll_dice(<span class="number">3</span>))</span><br><span class="line">print(add())</span><br><span class="line">print(add(<span class="number">1</span>))			<span class="comment">#a</span></span><br><span class="line">print(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">print(add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))	<span class="comment">#a b c</span></span><br><span class="line">print(add(c=<span class="number">50</span>,a=<span class="number">100</span>,b=<span class="number">200</span>))	<span class="comment">#change the order</span></span><br></pre></td></tr></table></figure>

<h2 id="use-module"><a href="#use-module" class="headerlink" title="use module "></a>use module </h2><p>For there is no function overload，it is necessary to use the module to extinct functions.<br><font color="red">module == .py</font></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello, world!'</span>)    <span class="comment">#covered</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'goodbye, world!'</span>)</span><br><span class="line">   </span><br><span class="line">foo();</span><br><span class="line">output: goodbye world</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">module1.py</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello, world!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module2.py</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'goodbye, world!'</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">test.py</span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo</span><br><span class="line"><span class="comment"># hello, world!</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> foo</span><br><span class="line"><span class="comment"># goodbye, world!</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">or</span> test1.py</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> module1 <span class="keyword">as</span> m1</span><br><span class="line"><span class="keyword">import</span> module2 <span class="keyword">as</span> m2</span><br><span class="line"></span><br><span class="line">m1.foo()</span><br><span class="line">m2.foo()</span><br></pre></td></tr></table></figure>
<h2 id="avoid-too-many-mains"><a href="#avoid-too-many-mains" class="headerlink" title="avoid too many mains"></a>avoid too many mains</h2><p>The python interpreter(解释器) would run all the codes in modules.<br>We can only run the function in modules by using ‘ __main__‘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(&apos;call foo()&apos;)</span><br><span class="line">    foo()</span><br></pre></td></tr></table></figure>

<h2 id="function-in-function"><a href="#function-in-function" class="headerlink" title="function in function"></a>function in function</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    b = &apos;hello&apos;</span><br><span class="line"></span><br><span class="line">    # we can define function in function </span><br><span class="line">    def bar():</span><br><span class="line">        c = True</span><br><span class="line">        print(a)</span><br><span class="line">        print(b)</span><br><span class="line">        print(c)</span><br><span class="line"></span><br><span class="line">    bar()</span><br><span class="line">    # print(c)  # NameError: name &apos;c&apos; is not defined</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    a = 100</span><br><span class="line">    # print(b)  # NameError: name &apos;b&apos; is not defined</span><br><span class="line">    foo()</span><br></pre></td></tr></table></figure>

<h2 id="2d-array-in-python"><a href="#2d-array-in-python" class="headerlink" title="2d array in python"></a>2d array in python</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">row=4</span><br><span class="line">column=3</span><br><span class="line">g = [[i+j for i in range(column)] for j in range(row)]</span><br><span class="line">print(g)</span><br></pre></td></tr></table></figure>

<p>from:<a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/07.字符串和常用数据结构.md" target="_blank" rel="noopener">https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/07.字符串和常用数据结构.md</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>bugs</tag>
      </tags>
  </entry>
  <entry>
    <title>pystring</title>
    <url>/2019/11/22/%22pystrings%22/</url>
    <content><![CDATA[<h2 id="1-routine-operation"><a href="#1-routine-operation" class="headerlink" title="1 routine operation"></a>1 routine operation</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">'hello, world!'</span></span><br><span class="line">s2 = <span class="string">"hello, world!"</span></span><br><span class="line">s3 = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">hello, </span></span><br><span class="line"><span class="string">world!</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line">s4=<span class="string">'\141\142\143\x61\x62\x63\n'</span> <span class="comment">#abcabc</span></span><br><span class="line">s5=<span class="string">'\u925c'</span><span class="comment">#unicode 汉字\u</span></span><br><span class="line"><span class="built_in">print</span>(s1, s2, s3, s4, s5)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'a'</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">s1= <span class="string">'di'</span> * 3;   <span class="comment">#cover s1 dididi</span></span><br><span class="line"><span class="built_in">print</span>(s1)       <span class="comment">#automatically \n</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'did'</span> <span class="keyword">in</span> s1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#slice</span></span><br><span class="line">str2 = <span class="string">'abc123456'</span></span><br><span class="line"><span class="built_in">print</span>(str2[2]) <span class="comment"># c</span></span><br><span class="line"><span class="comment">#from index to index</span></span><br><span class="line"><span class="built_in">print</span>(str2[2:5]) <span class="comment"># c12</span></span><br><span class="line"><span class="built_in">print</span>(str2[2:]) <span class="comment"># c123456</span></span><br><span class="line"><span class="built_in">print</span>(str2[2::2]) <span class="comment"># c246</span></span><br><span class="line"><span class="built_in">print</span>(str2[::2]) <span class="comment"># ac246</span></span><br><span class="line"><span class="built_in">print</span>(str2[::-1]) <span class="comment"># 654321cba</span></span><br><span class="line"><span class="built_in">print</span>(str2[-3:-1]) <span class="comment"># 45</span></span><br></pre></td></tr></table></figure>

<h2 id="2-functions"><a href="#2-functions" class="headerlink" title="2 functions"></a>2 functions</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str1 = &apos;hello, world!&apos;</span><br><span class="line"># 通过内置函数len计算字符串的长度</span><br><span class="line">print(len(str1)) # 13</span><br><span class="line"># 获得字符串首字母大写的拷贝</span><br><span class="line">print(str1.capitalize()) # Hello, world!</span><br><span class="line"># 获得字符串每个单词首字母大写的拷贝</span><br><span class="line">print(str1.title()) # Hello, World!</span><br><span class="line"># 获得字符串变大写后的拷贝</span><br><span class="line">print(str1.upper()) # HELLO, WORLD!</span><br><span class="line"># 从字符串中查找子串所在位置</span><br><span class="line">print(str1.find(&apos;or&apos;)) # 8</span><br><span class="line">print(str1.find(&apos;shit&apos;)) # -1</span><br><span class="line"># 与find类似但找不到子串时会引发异常</span><br><span class="line"># print(str1.index(&apos;or&apos;))</span><br><span class="line"># print(str1.index(&apos;shit&apos;))</span><br><span class="line"># 检查字符串是否以指定的字符串开头</span><br><span class="line">print(str1.startswith(&apos;He&apos;)) # False</span><br><span class="line">print(str1.startswith(&apos;hel&apos;)) # True</span><br><span class="line"># 检查字符串是否以指定的字符串结尾</span><br><span class="line">print(str1.endswith(&apos;!&apos;)) # True</span><br><span class="line"># 将字符串以指定的宽度居中并在两侧填充指定的字符</span><br><span class="line">print(str1.center(50, &apos;*&apos;))</span><br><span class="line"># 将字符串以指定的宽度靠右放置左侧填充指定的字符</span><br><span class="line">print(str1.rjust(50, &apos; &apos;))</span><br><span class="line">str2 = &apos;abc123456&apos;</span><br><span class="line"># 检查字符串是否由数字构成</span><br><span class="line">print(str2.isdigit())  # False</span><br><span class="line"># 检查字符串是否以字母构成</span><br><span class="line">print(str2.isalpha())  # False</span><br><span class="line"># 检查字符串是否以数字和字母构成</span><br><span class="line">print(str2.isalnum())  # True</span><br><span class="line">str3 = &apos;  jackfrued@126.com &apos;</span><br><span class="line">print(str3)</span><br><span class="line"># 获得字符串修剪左右两侧空格之后的拷贝</span><br><span class="line">print(str3.strip())</span><br></pre></td></tr></table></figure>

<h2 id="3-output"><a href="#3-output" class="headerlink" title="3 output"></a>3 output</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们之前讲过，可以用下面的方式来格式化输出字符串。</span><br><span class="line"></span><br><span class="line">a, b = 5, 10</span><br><span class="line">print(&apos;%d * %d = %d&apos; % (a, b, a * b))</span><br><span class="line">当然，我们也可以用字符串提供的方法来完成字符串的格式，</span><br><span class="line">代码如下所示。</span><br><span class="line"></span><br><span class="line">a, b = 5, 10</span><br><span class="line">print(&apos;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&apos;.format(a, b, a * b))</span><br><span class="line"></span><br><span class="line">Python 3.6以后，格式化字符串还有更为简洁的书写方式，</span><br><span class="line">就是在字符串前加上字母f，</span><br><span class="line">我们可以使用下面的语法糖来简化上面的代码。</span><br><span class="line"></span><br><span class="line">a, b = 5, 10</span><br><span class="line">print(f&apos;&#123;a&#125; * &#123;b&#125; = &#123;a * b&#125;&apos;)</span><br></pre></td></tr></table></figure>

<p>from:<a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/07.字符串和常用数据结构.md" target="_blank" rel="noopener">https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/07.字符串和常用数据结构.md</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>string</tag>
      </tags>
  </entry>
  <entry>
    <title>set and dictionary</title>
    <url>/2019/11/22/%22set%20and%20dictionary%22/</url>
    <content><![CDATA[<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set1=&#123;6,3,4,2,7&#125;</span><br><span class="line">print(set1)</span><br><span class="line">print(len(set1))</span><br><span class="line">set2 = set(range(1, 10)) #use constructor</span><br><span class="line">set3 = set((1, 2, 3, 3, 2, 1))#use constuvtor</span><br><span class="line">print(set2,set3)</span><br><span class="line">set4 = &#123;num for num in range(1, 10) if num % 3 == 0 or num % 5 == 0&#125;</span><br><span class="line">print(set4)</span><br><span class="line">set1.add(4)</span><br><span class="line">set1.add(5)</span><br><span class="line">set1.add(5)     #no problem, clever python ! </span><br><span class="line">set2.update([11, 12])</span><br><span class="line">print(set2)</span><br><span class="line">set2.discard(5)</span><br><span class="line">print(set2)</span><br><span class="line">set2.discard(5)  #no problem</span><br><span class="line">print(set2)</span><br><span class="line">set2.pop()          #pop from head</span><br><span class="line">print(set2)</span><br><span class="line">print(&quot;.................................&quot;)</span><br><span class="line"></span><br><span class="line"># 集合的交集、并集、差集、对称差运算</span><br><span class="line">print(set1 &amp; set2)</span><br><span class="line"># print(set1.intersection(set2))</span><br><span class="line">print(set1 | set2)</span><br><span class="line"># print(set1.union(set2))</span><br><span class="line">print(set1 - set2)</span><br><span class="line"># print(set1.difference(set2))</span><br><span class="line">print(set1 ^ set2)#(subtravting)</span><br><span class="line"># print(set1.symmetric_difference(set2))</span><br><span class="line"># 判断子集和超集</span><br><span class="line">print(set2 &lt;= set1)</span><br><span class="line"># print(set2.issubset(set1))</span><br><span class="line">print(set3 &lt;= set1)</span><br><span class="line"># print(set3.issubset(set1))</span><br><span class="line">print(set1 &gt;= set2)</span><br><span class="line"># print(set1.issuperset(set2))</span><br><span class="line">print(set1 &gt;= set3)</span><br><span class="line"># print(set1.issuperset(set3))</span><br><span class="line">#print(&#123;1, 2&#125; &gt; &#123;1&#125;)  # True</span><br></pre></td></tr></table></figure>

<h2 id="dictionary"><a href="#dictionary" class="headerlink" title="dictionary"></a>dictionary</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建字典的字面量语法</span><br><span class="line">scores = &#123;&apos;骆昊&apos;: 95, &apos;白元芳&apos;: 78, &apos;狄仁杰&apos;: 82&#125;</span><br><span class="line">print(scores)</span><br><span class="line"># 创建字典的构造器语法</span><br><span class="line">items1 = dict(one=1, two=2, three=3, four=4)</span><br><span class="line"># 通过zip函数将两个序列压成字典</span><br><span class="line">items2 = dict(zip([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;], &apos;123&apos;))</span><br><span class="line"># 创建字典的推导式语法</span><br><span class="line">items3 = &#123;num: num ** 2 for num in range(1, 10)&#125;</span><br><span class="line">print(items1, items2, items3)</span><br><span class="line"># 通过键可以获取字典中对应的值</span><br><span class="line">print(scores[&apos;骆昊&apos;])</span><br><span class="line">print(scores[&apos;狄仁杰&apos;])</span><br><span class="line"># 对字典中所有键值对进行遍历</span><br><span class="line">for key in scores:</span><br><span class="line">    print(f&apos;&#123;key&#125;: &#123;scores[key]&#125;&apos;)</span><br><span class="line"># 更新字典中的元素</span><br><span class="line">scores[&apos;白元芳&apos;] = 65</span><br><span class="line">scores[&apos;诸葛王朗&apos;] = 71  #python would add it  </span><br><span class="line">automatically</span><br><span class="line">scores.update(冷面=67, 方启鹤=85)</span><br><span class="line">print(scores)</span><br><span class="line">if &apos;武则天&apos; in scores:</span><br><span class="line">    print(scores[&apos;武则天&apos;])</span><br><span class="line">print(scores.get(&apos;武则天&apos;))</span><br><span class="line"># get方法也是通过键获取对应的值但是可以设置默认值</span><br><span class="line">print(scores.get(&apos;武则天&apos;, 60))</span><br><span class="line"># 删除字典中的元素</span><br><span class="line">print(scores.popitem())</span><br><span class="line">print(scores.popitem())</span><br><span class="line">print(scores.pop(&apos;骆昊&apos;, 100))</span><br><span class="line"># 清空字典</span><br><span class="line">scores.clear()</span><br><span class="line">print(scores)</span><br></pre></td></tr></table></figure>

<p>from:<a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/07.字符串和常用数据结构.md" target="_blank" rel="noopener">https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/07.字符串和常用数据结构.md</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>list in py</title>
    <url>/2019/11/22/%22list%20in%20py%22/</url>
    <content><![CDATA[<h2 id="1-what-is-list-py"><a href="#1-what-is-list-py" class="headerlink" title="1 what is list(py)"></a>1 what is list(py)</h2><p>List in python is barely an array,which can contain int,double,char and etc.<br>And,it is almost the same as vector;</p>
<h2 id="2-commmon-usage"><a href="#2-commmon-usage" class="headerlink" title="2 commmon usage "></a>2 commmon usage </h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1 = [1, 3, 5, 7, 100]</span><br><span class="line">print(list1) # [1, 3, 5, 7, 100]</span><br><span class="line">print(len(list1)) # 5</span><br><span class="line">print(list1[-1]) # 100</span><br><span class="line"></span><br><span class="line">for index in range(len(list1)):</span><br><span class="line">    print(list1[index])</span><br><span class="line"># for</span><br><span class="line">for elem in list1:</span><br><span class="line">    print(elem)</span><br><span class="line"># function enumerate</span><br><span class="line">for index, elem in enumerate(list1):</span><br><span class="line">    print(index, elem)</span><br><span class="line"></span><br><span class="line">list1.append(200)</span><br><span class="line">list1.insert(1, 400)    #1-&gt;2 , 1= 400</span><br><span class="line">print(list1)</span><br><span class="line"># list1.extend([1000, 2000])</span><br><span class="line">list1 += [1000, 2000]</span><br><span class="line">print(list1) # [1, 400, 3, 5, 7, 100, 200, 1000, 2000]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list1.append(1000)</span><br><span class="line">list1.remove(1000)  #only remove the 1000 whith a lower index</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list1.append(1000)</span><br><span class="line">if 1000 in list1:</span><br><span class="line">	list1.remove(1000) #only remove the 1000 with a lower index</span><br><span class="line">print(list1)</span><br><span class="line">    </span><br><span class="line">list1.pop(len(list1) - 1)#the last one poped</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line">list1.clear()</span><br></pre></td></tr></table></figure>

<h2 id="3-slice"><a href="#3-slice" class="headerlink" title="3 slice"></a>3 slice</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruits = [&apos;grape&apos;, &apos;apple&apos;, &apos;strawberry&apos;, &apos;waxberry&apos;]</span><br><span class="line">fruits += [&apos;pitaya&apos;, &apos;pear&apos;, &apos;mango&apos;]</span><br><span class="line">fruits2 = fruits[1:5]</span><br><span class="line">print(fruits2) # apple strawberry waxberry pitaya</span><br><span class="line">fruits3 = fruits[:]</span><br><span class="line">print(fruits3) # [&apos;grape&apos;, &apos;apple&apos;, &apos;strawberry&apos;, &apos;waxberry&apos;, &apos;pitaya&apos;, &apos;pear&apos;, &apos;mango&apos;]</span><br><span class="line">fruits4 = fruits[-3:-1]</span><br><span class="line">print(fruits4) # [&apos;pitaya&apos;, &apos;pear&apos;]</span><br><span class="line">fruits5 = fruits[::-1]</span><br><span class="line">print(fruits5) # [&apos;mango&apos;, &apos;pear&apos;, &apos;pitaya&apos;, &apos;waxberry&apos;, &apos;strawberry&apos;, &apos;apple&apos;, &apos;grape&apos;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list1 = sorted(fruits)#the fruits won&apos;t change</span><br><span class="line">print(list1)</span><br><span class="line">list1.sort(reverse=True)#list3 = sorted(list1, reverse=True)</span><br><span class="line">print(list1)</span><br><span class="line">list4 = sorted(list1, key=len)#sort the strings based on the length</span><br><span class="line">print(list4)</span><br></pre></td></tr></table></figure>

<h2 id="4-generative-formula-amp-generator"><a href="#4-generative-formula-amp-generator" class="headerlink" title="4 generative formula &amp; generator"></a>4 generative formula &amp; generator</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">f = [x for x in range(1, 10)]</span><br><span class="line">print(f)</span><br><span class="line">f = [x + y for x in &apos;ABCDE&apos; for y in &apos;1234567&apos;]</span><br><span class="line">print(f)</span><br><span class="line"># 用列表的生成表达式语法创建列表容器</span><br><span class="line"># 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间</span><br><span class="line">f = [x ** 2 for x in range(1, 10)]</span><br><span class="line">print(sys.getsizeof(f))  # 查看对象占用内存的字节数 192</span><br><span class="line">print(f)</span><br><span class="line"># 请注意下面的代码创建的不是一个列表而是一个生成器对象</span><br><span class="line"># 通过生成器可以获取到数据但它不占用额外的空间存储数据    (额外是指比正常多一点)</span><br><span class="line"># 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)</span><br><span class="line">f = (x ** 2 for x in range(1, 10))</span><br><span class="line">print(sys.getsizeof(f))  # 相比生成式生成器不占用存储数据的空间 120</span><br><span class="line">for val in f:</span><br><span class="line">    print(val)</span><br></pre></td></tr></table></figure>
<h2 id="5-tuple"><a href="#5-tuple" class="headerlink" title="5 tuple"></a>5 tuple</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The tuple is &quot;const&quot;,it&apos;s almost the same as list.</span><br><span class="line"># initialization</span><br><span class="line">t = (&apos;ww&apos;, 38, True, &apos;从重重&apos;)</span><br><span class="line">print(t)</span><br><span class="line"># show the tuple</span><br><span class="line">print(t[0])</span><br><span class="line">print(t[3])</span><br><span class="line"># travelsal the value in tuple</span><br><span class="line">for member in t:</span><br><span class="line">    print(member)</span><br><span class="line"># re-assignment to tuple</span><br><span class="line"># t[0] = &apos;王大锤&apos;  # TypeError</span><br><span class="line"># delete the old tuple and create a new one </span><br><span class="line">t = (&apos;王大锤&apos;, 20, True, &apos;云南昆明&apos;)</span><br><span class="line">print(t)</span><br><span class="line"># change tuple into list</span><br><span class="line">person = list(t)</span><br><span class="line">print(person)</span><br><span class="line"># we can change the element in list</span><br><span class="line">person[0] = &apos;李小龙&apos;</span><br><span class="line">person[1] = 25</span><br><span class="line">print(person)</span><br><span class="line"># change list into tuple </span><br><span class="line">fruits_list = [&apos;apple&apos;, &apos;banana&apos;, &apos;orange&apos;]</span><br><span class="line">fruits_tuple = tuple(fruits_list)</span><br><span class="line">print(fruits_tuple)</span><br><span class="line"></span><br><span class="line">这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什 </span><br><span class="line">么还需要元组这样的类型呢？</span><br><span class="line"></span><br><span class="line">1 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后  </span><br><span class="line">面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不</span><br><span class="line">能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个  </span><br><span class="line">不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线 </span><br><span class="line">程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这  </span><br><span class="line">样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访 </span><br><span class="line">问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候,  </span><br><span class="line">可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2 元组在创建时间和占用的空间上面都优于列表。</span><br></pre></td></tr></table></figure>

<p>from:<a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/07.字符串和常用数据结构.md" target="_blank" rel="noopener">https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/07.字符串和常用数据结构.md</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>大一计算机笔试复习</title>
    <url>/2019/11/22/%22set%20and%20dictionary%22%E7%9A%84%E5%89%AF%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="数值、逻辑表达式与运算符"><a href="#数值、逻辑表达式与运算符" class="headerlink" title="数值、逻辑表达式与运算符"></a>数值、逻辑表达式与运算符</h1><h2 id="优先级与结合性"><a href="#优先级与结合性" class="headerlink" title="优先级与结合性"></a>优先级与结合性</h2><ol>
<li><ul>
<li>/ % 优先于 + -</li>
</ul>
</li>
<li><ul>
<li>/ 都是从左到右结合的，就是说先算左边的</li>
</ul>
</li>
</ol>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ol>
<li>将一种类型的值赋给另一种时，表达式包含不同类型，函数传递参数时会进行类型转换</li>
<li>乘除法只要有一个是浮点，默认结果是浮点</li>
<li>短转长没啥子问题，长变短就会截断</li>
<li>P64蓝字</li>
</ol>
<h2 id="坑坑子"><a href="#坑坑子" class="headerlink" title="坑坑子"></a>坑坑子</h2><ol>
<li>#define是纯粹的宏替换，相当于直接抄过去，很多坑</li>
<li>用浮点数时，注意eps，不能单纯的==；且1.0+3.0不一定等于4.0</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>AI Basics</title>
    <url>/2019/11/22/AI%20Basics/</url>
    <content><![CDATA[<h2 id="Supervised-learning"><a href="#Supervised-learning" class="headerlink" title="Supervised learning"></a>Supervised learning</h2><p><img src="/2019/11/22/AI%20Basics/1.jpg" alt></p>
<p>赛车游戏视频传送门：<a href="https://www.youtube.com/watch?v=wL7tSgUpy8wOpenAI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=wL7tSgUpy8wOpenAI</a> Gym赛车场：<a href="https://gym.openai.com/envs/CarRacing-v0/Flappy" target="_blank" rel="noopener">https://gym.openai.com/envs/CarRacing-v0/Flappy</a> Bird代码传送门：<a href="https://github.com/ssusnic/Machine-Learning-Flappy-BirdPacman代码传送门：https://github.com/Code-Bullet/PacNeat" target="_blank" rel="noopener">https://github.com/ssusnic/Machine-Learning-Flappy-BirdPacman代码传送门：https://github.com/Code-Bullet/PacNeat</a> (NEAT算法)<a href="https://github.com/Code-Bullet/PacmanGame" target="_blank" rel="noopener">https://github.com/Code-Bullet/PacmanGame</a> (搭建游戏环境)</p>
<p>作者：量子位<br>链接：<a href="https://www.zhihu.com/question/31497611/answer/601785142" target="_blank" rel="noopener">https://www.zhihu.com/question/31497611/answer/601785142</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/11/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP</title>
    <url>/2019/11/22/TCP:IP/</url>
    <content><![CDATA[<h2 id="what-is-tcp-ip"><a href="#what-is-tcp-ip" class="headerlink" title="what is tcp/ip"></a>what is tcp/ip</h2><p>TCP/IP(Transmission Control Protocol / Internet Protocol) is a computer<br>communication protocol for internet.</p>
<p>The TCP/IP relationship is similar to sending someone a message written on a puzzle through the mail. The message is written down and the puzzle is broken into pieces. Each piece then can travel through a different postal route, some of which take longer than others. When the puzzle pieces arrive after traversing their different paths, the pieces may be out of order. The Internet Protocol makes sure the pieces arrive at their destination address. The TCP protocol can be thought of as the puzzle assembler on the other side who puts the pieces together in the right order, asks for missing pieces to be resent, and lets the sender know the puzzle has been received. TCP maintains the connection with the sender from before the first puzzle piece is sent to after the final piece is sent.</p>
<h2 id="3-handshakes"><a href="#3-handshakes" class="headerlink" title="3 handshakes"></a>3 handshakes</h2><p>For example, when an email is sent over TCP, a connection is established and a 3-way handshake is made. First, the source send an SYN “initial request” packet to the target server in order to start the dialogue. Then the target server then sends a SYN-ACK packet to agree to the process. Lastly, the source sends an ACK packet to the target to confirm the process, after which the message contents can be sent. The email message is ultimately broken down into packets before each packet is sent out into the Internet, where it traverses a series of gateways before arriving at the target device where the group of packets are reassembled by TCP into the original contents of the email.</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>python &amp; class</title>
    <url>/2019/11/22/python%20&amp;%20class/</url>
    <content><![CDATA[<h2 id="what-is-Object-oriented"><a href="#what-is-Object-oriented" class="headerlink" title="what is Object-oriented?"></a>what is Object-oriented?</h2><ol>
<li><p>process-oriented programming<br>advantages: fast, assembly-line-like<br>disadvantages: hard to maintain, reuse and expand<br>(the code is very long and independent, and hard to be modified)   </p>
</li>
<li><p>object-oriented programming<br>advantages: easy to maintain, reuse and expand<br>(the code is shorter and easier to read, and much more flexible)<br>disadvantages: slower, more complex,huge class library  </p>
</li>
</ol>
<p><img src="/2019/11/22/python%20&%20class/blogpy1.png" alt></p>
<h2 id="basics"><a href="#basics" class="headerlink" title="basics"></a>basics</h2><ol>
<li>data + method = object  </li>
<li>‘similar’ objects = class</li>
<li>we can use encapsulation(封装) in class to hide the details</li>
<li>we can use inheritance(继承) to specialize or generalize</li>
<li>we can imply dynamic dispatch based on object type by using polymorphism</li>
<li>class is the blueprint of object, while object is the instance of class </li>
</ol>
<h2 id="“private”-in-python"><a href="#“private”-in-python" class="headerlink" title="“private” in python"></a>“private” in python</h2><p>If you want to define a “private” member, you can define it as __name.<br>Actually, it is not “private”, we can access by analysing its name.<br>__name-&gt;private, _name-&gt;protected  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test:</span><br><span class="line"></span><br><span class="line">    def __init__(self, foo): #constuctor</span><br><span class="line">        self.__foo = foo</span><br><span class="line">#we can analogy self to *this in C</span><br><span class="line">    def __bar(self):</span><br><span class="line">        print(self.__foo)</span><br><span class="line">        print(&apos;__bar&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    test = Test(&apos;hello&apos;)</span><br><span class="line">    test._Test__bar()</span><br><span class="line">    print(test._Test__foo)</span><br><span class="line"># we can access the __foo in this way</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="getter-and-setter"><a href="#getter-and-setter" class="headerlink" title="getter and setter"></a>getter and setter</h2><p>If we use instance.property(属性，财产等), the name of our private members would be exposed, and others can access it.To avoid it, the getter and setter method are necessary.<br>And we can check the input here.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def get_score(self):</span><br><span class="line">         return self._score</span><br><span class="line"></span><br><span class="line">    def set_score(self, value):</span><br><span class="line">        if not isinstance(value, int):	#judge the type of instance</span><br><span class="line">            raise ValueError(&apos;score must be an integer!&apos;)</span><br><span class="line">        if value &lt; 0 or value &gt; 100:</span><br><span class="line">            raise ValueError(&apos;score must between 0 ~ 100!&apos;)</span><br><span class="line">        self._score = value</span><br><span class="line"></span><br><span class="line">if __name__ == :&quot;__main__&quot;:</span><br><span class="line">	s = Student()</span><br><span class="line">	s.set_score(60)</span><br><span class="line">	s.get_score()</span><br></pre></td></tr></table></figure>

<p>To simplify, the built-in decorator @property(属性，性能，财产) is the best choice.<br>It can change a method to a property.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def birth(self):</span><br><span class="line">        return self._birth</span><br><span class="line"></span><br><span class="line">    @birth.setter		#r, ifndef it, it is an read-only property</span><br><span class="line">    def birth(self, value):</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line">    @property				</span><br><span class="line">    def age(self):</span><br><span class="line">        return 2015 - self._birth</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">	s = Student()</span><br><span class="line">	s.score=60</span><br><span class="line">	print(s.score)</span><br></pre></td></tr></table></figure>


<h2 id="super"><a href="#super" class="headerlink" title="super()"></a>super()</h2><p><a href="https://www.runoob.com/python/python-func-super.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-func-super.html</a></p>
<h2 id="instance-method-amp-classmethod-amp-staticmethod"><a href="#instance-method-amp-classmethod-amp-staticmethod" class="headerlink" title="instance method &amp; classmethod &amp; staticmethod"></a>instance method &amp; classmethod &amp; staticmethod</h2><p>instance method<br>This is the general method to call function in a class.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def foo(self, x):</span><br><span class="line">        print(&quot;running foo(%s, %s)&quot; % (self, x))</span><br><span class="line"></span><br><span class="line"># we need an instance to call the function</span><br><span class="line">a = A()</span><br><span class="line">a.foo(&quot;test&quot;)</span><br></pre></td></tr></table></figure>

<p>classmethod<br>If we don’t need interaction with instance, we can call<br>function with the name of class. The class method passing a whole class.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class A:</span><br><span class="line">    class_attr = &quot;attr&quot;</span><br><span class="line">    </span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">        </span><br><span class="line">    @classmethod</span><br><span class="line">    def class_foo(cls):</span><br><span class="line">        print(&quot;running class_foo(%s)&quot; % (cls.class_attr))</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.class_foo()</span><br><span class="line">A.class_foo()</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">static method  </span><br><span class="line">It is sth like static in c++,similar to instance  </span><br><span class="line">method, and free of the self parameter.</span><br></pre></td></tr></table></figure>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>log_enabled = True</p>
<p>class A:<br>    class_attr = “attr”</p>
<pre><code>def __init__(self):
    pass

@staticmethod
def static_foo():
    if log_enabled:
        print(&quot;log is enabled&quot;)
    else:
        print(&quot;log is disabled&quot;)</code></pre><p>A.static_foo()</p>
<p>```</p>
<p>thx:<a href="https://www.cnblogs.com/zhangmingyan/p/11424562.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangmingyan/p/11424562.html</a><br>thx:<a href="https://www.cnblogs.com/miqi1992/p/8343234.html" target="_blank" rel="noopener">https://www.cnblogs.com/miqi1992/p/8343234.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>OO</tag>
      </tags>
  </entry>
  <entry>
    <title>decorators in python</title>
    <url>/2019/11/22/py%20decorators/</url>
    <content><![CDATA[<h2 id="What-is-decorator-in-py"><a href="#What-is-decorator-in-py" class="headerlink" title="What is decorator in py?"></a>What is decorator in py?</h2><p>Decorator can modify the function of function in order to simplify the code,<br>which means we can reuse our code wisely.<br>Essentially(本质上), the decorator is a function or a class, it can add sth to function or class<br>without modify the code(just add sth), and it returns a function or a class.</p>
<p>Decorator is often used in scenarios(情景，脚本) with aspect needs.(切面需求  AOP 意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术)<br>for example, Insert log, performance test, transaction processing(事务处理), caching(缓存) and permission check.</p>
<p>let’s learn some preliminary knowledge.</p>
<h2 id="everything-in-python-can-be-an-object"><a href="#everything-in-python-can-be-an-object" class="headerlink" title="everything in python can be an object  "></a>everything in python can be an object  </h2><p>for example, we can use a function as an object.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def hi(name=&quot;yasoob&quot;):</span><br><span class="line">    return &quot;hi &quot; + name</span><br><span class="line"> </span><br><span class="line">print(hi())</span><br><span class="line"># output: &apos;hi yasoob&apos;</span><br><span class="line"> </span><br><span class="line"># we can even assign a function to a variable</span><br><span class="line">greet = hi</span><br><span class="line"># we don&apos;t use the (), because we don&apos;t want to call functions</span><br><span class="line"># but we put it in a varieble &apos;greet&apos;</span><br><span class="line"> </span><br><span class="line">print(greet())</span><br><span class="line"># output: &apos;hi yasoob&apos;</span><br><span class="line"> </span><br><span class="line"># what would happen if we delete the function &apos;hi&apos;?</span><br><span class="line">del hi</span><br><span class="line">print(hi())</span><br><span class="line">#outputs: NameError</span><br><span class="line"> </span><br><span class="line">print(greet())</span><br><span class="line">#outputs: &apos;hi yasoob&apos;</span><br></pre></td></tr></table></figure>

<h2 id="define-and-return-a-function-in-a-function"><a href="#define-and-return-a-function-in-a-function" class="headerlink" title="define and return a function in a function"></a>define and return a function in a function</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def hi(name=&quot;yasoob&quot;):</span><br><span class="line">    def greet():</span><br><span class="line">        return &quot;now you are in the greet() function&quot;</span><br><span class="line"> </span><br><span class="line">    def welcome():</span><br><span class="line">        return &quot;now you are in the welcome() function&quot;</span><br><span class="line"> </span><br><span class="line">    if name == &quot;yasoob&quot;:</span><br><span class="line">        return greet</span><br><span class="line">    else:</span><br><span class="line">        return welcome</span><br><span class="line"> </span><br><span class="line">a = hi()</span><br><span class="line">print(a)</span><br><span class="line">#outputs: &lt;function greet at 0x7f2143c01500&gt;</span><br><span class="line"> </span><br><span class="line">#a-&gt;&amp;greet()</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">print(a())</span><br><span class="line">#outputs: now you are in the greet() function  #a()-&gt;run the function</span><br><span class="line">print(hi()())</span><br><span class="line">#outputs: now you are in the greet() function  #?????</span><br></pre></td></tr></table></figure>

<p>So, we can use function without the “()” as a parameter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def hi():</span><br><span class="line">    return &quot;hi yasoob!&quot;</span><br><span class="line"> </span><br><span class="line">def doSomethingBeforeHi(func):			#transfer the address of the func</span><br><span class="line">    print(&quot;I am doing some boring work before executing hi()&quot;)</span><br><span class="line">    print(func())</span><br><span class="line">	 # remember that if we don&apos;t use print(), we can&apos;t get the returned on screen</span><br><span class="line">doSomethingBeforeHi(hi)</span><br><span class="line">#outputs:I am doing some boring work before executing hi()</span><br><span class="line">#        hi yasoob!</span><br></pre></td></tr></table></figure>

<h2 id="how-can-we-understand-the-process-of-a-decorator"><a href="#how-can-we-understand-the-process-of-a-decorator" class="headerlink" title="how can we understand the process of a decorator"></a>how can we understand the process of a decorator</h2><p>actually, it is something like this:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def use_logging(func):</span><br><span class="line"></span><br><span class="line">    def wrapper():		</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func()   </span><br><span class="line">    return wrapper</span><br><span class="line">#Functions&apos; entrance and exit is an &quot;aspect&quot;.(AOP)</span><br><span class="line">def foo():</span><br><span class="line">    print(&apos;i am foo&apos;)</span><br><span class="line"></span><br><span class="line">foo = use_logging(foo)  # As we returned the func wrapper，it is equal to foo = wrapper(a foo have decorated)</span><br><span class="line">foo()                   # run the decorated foo()</span><br></pre></td></tr></table></figure>

<p>And we have the @ syntactic sugar(语法糖), by using it, we can omit the last step to assign again.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def use_logging(func):</span><br><span class="line"></span><br><span class="line">    def wrapper():</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func()</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@use_logging			#use the @ syntactic sugar before the head of a function</span><br><span class="line">def foo():</span><br><span class="line">    print(&quot;i am foo&quot;)</span><br><span class="line"></span><br><span class="line">foo()					#foo = use_logging(foo) (we have used @ to simplify)</span><br></pre></td></tr></table></figure>
<p>Now we can add sth to the function without modify it, we can reuse the function.</p>
<h2 id="args、-kwargs"><a href="#args、-kwargs" class="headerlink" title="*args、**kwargs"></a>*args、**kwargs</h2><h2 id="decorator-with-parameters"><a href="#decorator-with-parameters" class="headerlink" title="decorator with parameters"></a>decorator with parameters</h2><h2 id="decorator-in-class"><a href="#decorator-in-class" class="headerlink" title="decorator in class"></a>decorator in class</h2><p>Decorators in class have the advantages of great flexibility, high cohesion, and encapsulation.<br>But there is a disadvantage that the meta information of the original function is gone.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    def __call__(self):		#method __call__ can call instance object as a function </span><br><span class="line">        print (&apos;class decorator runing&apos;)</span><br><span class="line">        self._func()</span><br><span class="line">        print (&apos;class decorator ending&apos;)</span><br><span class="line">@Foo</span><br><span class="line">def bar():</span><br><span class="line">    print (&apos;bar&apos;)</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line"></span><br><span class="line">#class decorator runing</span><br><span class="line">#bar</span><br><span class="line">#class decorator ending</span><br></pre></td></tr></table></figure>

<h2 id="the-order-of-decorator"><a href="#the-order-of-decorator" class="headerlink" title="the order of decorator"></a>the order of decorator</h2><p>We can define many decorator in a single function.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@a</span><br><span class="line">@b</span><br><span class="line">@c</span><br><span class="line">def f ():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">#f = a(b(c(f)))</span><br></pre></td></tr></table></figure>

<p>from: <a href="https://www.runoob.com/w3cnote/python-func-decorators.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/python-func-decorators.html</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>ex</tag>
      </tags>
  </entry>
  <entry>
    <title>file operator in python</title>
    <url>/2019/11/22/python%20&amp;%20file/</url>
    <content><![CDATA[<h2 id="read-file"><a href="#read-file" class="headerlink" title="read file"></a>read file</h2><p>To open a file, the file path is nacessary (Relative or absolute path).<br>And, we should set the encoding parameter the same as the file encoding.</p>
<p>there is a example of a txt:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def main():</span><br><span class="line">    f = open(&apos;致橡树.txt&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">    print(f.read())</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>but it is not robust, so we should add sth to avoid program crashes if there is an error.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def main():</span><br><span class="line">    f = None</span><br><span class="line">    try:</span><br><span class="line">        f = open(&apos;致橡树.txt&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;)</span><br><span class="line">        print(f.read())</span><br><span class="line">    except FileNotFoundError:</span><br><span class="line">        print(&apos;无法打开指定的文件!&apos;)</span><br><span class="line">    except LookupError:</span><br><span class="line">        print(&apos;指定了未知的编码!&apos;)</span><br><span class="line">    except UnicodeDecodeError:</span><br><span class="line">        print(&apos;读取文件时解码错误!&apos;)</span><br><span class="line">    finally:</span><br><span class="line">        if f:</span><br><span class="line">            f.close()</span><br><span class="line"># 3 kinds of errors</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>In Python, we can put the code with potential risk in<br>the “try” block, and set adequate “except” to capture<br>potential errors.  </p>
<p>In this example, imply that there are three kind of<br>errors in file reading.At last we used the finally<br>block to close the file,to free up external resources<br>obtained in the program.We should notice that whether<br>the program is normal or abnormal, it will be executed.  </p>
<p>If you don’t like to use the finally block, you can use<br>context(上下文) syntex.Just specify the context of the file object with the<br>with keyword and automatically release file resources when leaving the context. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        with open(&apos;filename.txt&apos;, &apos;r&apos;, encoding=&apos;utf-8&apos;) as f:</span><br><span class="line">            print(f.read())</span><br><span class="line">    except FileNotFoundError:</span><br><span class="line">        print(&apos;无法打开指定的文件!&apos;)</span><br><span class="line">    except LookupError:</span><br><span class="line">        print(&apos;指定了未知的编码!&apos;)</span><br><span class="line">    except UnicodeDecodeError:</span><br><span class="line">        print(&apos;读取文件时解码错误!&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>Moreover, we can read the file in lines.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time </span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    with open(&apos;666.txt&apos;,&apos;r&apos;) as f: #we should notice that encoding was not included</span><br><span class="line">        for i in f:</span><br><span class="line">            print(i,end=&apos;&apos;)</span><br><span class="line">            time.sleep(0.2)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    #we can read the file in a list too</span><br><span class="line">    with open(&apos;666.txt&apos;,&apos;r&apos;) as f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    print(lines) # print the list line</span><br><span class="line">            </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="write-file"><a href="#write-file" class="headerlink" title="write file"></a>write file</h2><p>It is easy, just change the ‘r’ into ‘w’.If you want to append write,<br>use ‘a’, and if the file does not exist, it will be created automatically.  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from math import sqrt</span><br><span class="line"></span><br><span class="line">def is_prime(n):</span><br><span class="line">    &quot;&quot;&quot;判断素数的函数&quot;&quot;&quot;</span><br><span class="line">    assert n &gt; 0  #assert would return the error if we can&apos;t meet its condition</span><br><span class="line">    for factor in range(2, int(sqrt(n)) + 1):</span><br><span class="line">        if n % factor == 0:</span><br><span class="line">            return False</span><br><span class="line">    return True if n != 1 else False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    filenames = (&apos;a.txt&apos;, &apos;b.txt&apos;, &apos;c.txt&apos;)</span><br><span class="line">    fs_list = []</span><br><span class="line">    try:</span><br><span class="line">        for filename in filenames:</span><br><span class="line">            fs_list.append(open(filename, &apos;w&apos;, encoding=&apos;utf-8&apos;))</span><br><span class="line">        for number in range(1, 10000):</span><br><span class="line">            if is_prime(number):</span><br><span class="line">                if number &lt; 100:</span><br><span class="line">                    fs_list[0].write(str(number) + &apos;\n&apos;)</span><br><span class="line">                elif number &lt; 1000:</span><br><span class="line">                    fs_list[1].write(str(number) + &apos;\n&apos;)</span><br><span class="line">                else:</span><br><span class="line">                    fs_list[2].write(str(number) + &apos;\n&apos;)</span><br><span class="line">    except IOError as ex:</span><br><span class="line">        print(ex)</span><br><span class="line">        print(&apos;写文件时发生错误!&apos;)</span><br><span class="line">    finally:</span><br><span class="line">        for fs in fs_list:</span><br><span class="line">            fs.close()</span><br><span class="line">    print(&apos;操作完成!&apos;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>


<h2 id="read-and-write-a-binary-file"><a href="#read-and-write-a-binary-file" class="headerlink" title="read and write a binary file"></a>read and write a binary file</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def main():</span><br><span class="line">    try:</span><br><span class="line">        with open(&apos;guido.jpg&apos;, &apos;rb&apos;) as fs1:</span><br><span class="line">            data = fs1.read()</span><br><span class="line">            print(type(data))  # &lt;class &apos;bytes&apos;&gt;</span><br><span class="line">            print(data)</span><br><span class="line">        with open(&apos;吉多.jpg&apos;, &apos;wb&apos;) as fs2:</span><br><span class="line">            fs2.write(data)	# make a duplicate one </span><br><span class="line">    except FileNotFoundError as e:</span><br><span class="line">        print(&apos;指定的文件无法打开.&apos;)</span><br><span class="line">    except IOError as e:</span><br><span class="line">        print(&apos;读写文件时出现错误.&apos;)</span><br><span class="line">    print(&apos;程序执行结束.&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>


<h2 id="json-module"><a href="#json-module" class="headerlink" title="json module"></a>json module</h2><p>from: <a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/11.文件和异常.md" target="_blank" rel="noopener">https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/11.文件和异常.md</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>file</tag>
      </tags>
  </entry>
  <entry>
    <title>python &amp; regular expression</title>
    <url>/2019/11/22/python%20&amp;%20regular%20expression/</url>
    <content><![CDATA[<h2 id="some-details…"><a href="#some-details…" class="headerlink" title="some details…"></a>some details…</h2><p><a href="https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.字符串和正则表达式.md" target="_blank" rel="noopener">https://github.com/jackfrued/Python-100-Days/blob/master/Day01-15/12.字符串和正则表达式.md</a></p>
<p>the book automate the boring stuff with python</p>
<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>1  sth about findall, it would match in ‘chunks’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">phoneRegex = re.compile(r&apos;\d\d\d&apos;)   #use re.VERBOSE to add comment（注释）</span><br><span class="line">mo=phoneRegex.findall(&apos;sadadajdadn556666dfdifo&apos;)</span><br><span class="line">print(mo)#[&apos;556&apos;, &apos;666&apos;] # not 556 566 666 666</span><br></pre></td></tr></table></figure>

<p>2  use () to slice a part</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">phoneRegex = re.compile(r&apos;(\d\d)\d&apos;)   #use re.VERBOSE to add comment（注释）</span><br><span class="line">mo=phoneRegex.findall(&apos;sadadajdadn123456dfdifo&apos;)</span><br><span class="line">print(mo)#[&apos;12&apos;, &apos;45&apos;]</span><br></pre></td></tr></table></figure>

<p>3.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">phoneRegex = re.compile(r&apos;&apos;&apos;(  #r means that we don&apos;t need extra /</span><br><span class="line">        ^https://pan.baidu.com/s/   #start with it</span><br><span class="line">        (.*)                        #match any</span><br><span class="line">        )&apos;&apos;&apos;, re.VERBOSE)   #use re.VERBOSE to add comment（注释）</span><br><span class="line">mo=phoneRegex.findall(&apos;https://pan.baidu.com/s/11onObcEP10PLVHD9yKFT3A#list/path=%2F&apos;)</span><br><span class="line">print(mo)</span><br><span class="line"></span><br><span class="line"># [(&apos;https://pan.baidu.com/s/11onObcEP10PLVHD9yKFT3A#list/path=%2F&apos;, &apos;11onObcEP10PLVHD9yKFT3A#list/path=%2F&apos;)]</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line"></span><br><span class="line">phoneRegex = re.compile(r&apos;&apos;&apos;  #r means that we don&apos;t need extra /</span><br><span class="line">        ^https://pan.baidu.com/s/   #start with it</span><br><span class="line">        (.*)                        #match any</span><br><span class="line">        &apos;&apos;&apos;, re.VERBOSE)   #use re.VERBOSE to add comment（注释）</span><br><span class="line">mo=phoneRegex.findall(&apos;https://pan.baidu.com/s/11onObcEP10PLVHD9yKFT3A#list/path=%2F&apos;)</span><br><span class="line">print(mo)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>大一计算机考试复习</title>
    <url>/2019/11/22/%E5%A4%A7%E4%B8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p><strong>链表，c字符串栈，继承，    名称空间，</strong>11章的vector看一看，转换函数,  自动类对象，<strong>概念，虚函数</strong></p>
<p>递归</p>
<p>表达式求值，类型转换，运算符的优先级（基本的）和结合性</p>
<p>循环条件的顺序与副作用  switch（它的break加班u 家结果完全不同），break和continue概念用法</p>
<p>数组的几个初始化方法<br>字符数组与字符串<br>结构体<br>new delete<br>指针与数组的转换</p>
<p>函数缺省</p>
<p>必须默认构造函数<br>this<br>运算符重载，通常返回一个值，不是一个引用</p>
<p>静态成员变量和静态成员函数<br>各个内存块存放什么</p>
<p>3种继承方式的区别</p>
<p>指针细节，指向一位数组的指针和指向int的指针</p>
<p>虚函数 多层 多态重点</p>
<p><a href="https://wenku.baidu.com/view/b9008bbdfd0a79563c1e72cc.html?sxts=1576906677424" target="_blank" rel="noopener">https://wenku.baidu.com/view/b9008bbdfd0a79563c1e72cc.html?sxts=1576906677424</a></p>
<p><a href="https://wenku.baidu.com/view/2718df6648d7c1c708a14579.html?sxts=1576906756881&amp;sxts=1576907248200" target="_blank" rel="noopener">https://wenku.baidu.com/view/2718df6648d7c1c708a14579.html?sxts=1576906756881&amp;sxts=1576907248200</a></p>
<p><a href="https://wenku.baidu.com/view/cca5d9f6ed3a87c24028915f804d2b160a4e864d.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/cca5d9f6ed3a87c24028915f804d2b160a4e864d.html</a><br>输入和输出<br>====<br>流操作算子：<a href="http://c.biancheng.net/view/275.html" target="_blank" rel="noopener">http://c.biancheng.net/view/275.html</a>   格式化输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n = 141;</span><br><span class="line">    //1) 分别以十六进制、十进制、八进制先后输出 n</span><br><span class="line">    cout &lt;&lt; &quot;1)&quot; &lt;&lt; hex &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; dec &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; oct &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    double x = 1234567.89, y = 12.34567;</span><br><span class="line">    //2)保留5位有效数字</span><br><span class="line">    cout &lt;&lt; &quot;2)&quot; &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; endl;</span><br><span class="line">    //3)保留小数点后面5位</span><br><span class="line">    cout &lt;&lt; &quot;3)&quot; &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    //4)科学计数法输出，且保留小数点后面5位</span><br><span class="line">    cout &lt;&lt; &quot;4)&quot; &lt;&lt; scientific &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    //5)非负数显示正号，输出宽度为12字符，宽度不足则用 * 填补</span><br><span class="line">    cout &lt;&lt; &quot;5)&quot; &lt;&lt; showpos &lt;&lt; fixed &lt;&lt; setw(12) &lt;&lt; setfill(&apos;*&apos;) &lt;&lt; 12.1 &lt;&lt; endl;</span><br><span class="line">    //6)非负数不显示正号，输出宽度为12字符，宽度不足则右边用填充字符填充</span><br><span class="line">    cout &lt;&lt; &quot;6)&quot; &lt;&lt; noshowpos &lt;&lt; setw(12) &lt;&lt; left &lt;&lt; 12.1 &lt;&lt; endl;</span><br><span class="line">    //7)输出宽度为 12 字符，宽度不足则左边用填充字符填充</span><br><span class="line">    cout &lt;&lt; &quot;7)&quot; &lt;&lt; setw(12) &lt;&lt; right &lt;&lt; 12.1 &lt;&lt; endl;</span><br><span class="line">    //8)宽度不足时，负号和数值分列左右，中间用填充字符填充</span><br><span class="line">    cout &lt;&lt; &quot;8)&quot; &lt;&lt; setw(12) &lt;&lt; internal &lt;&lt; -12.1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;9)&quot; &lt;&lt; 12.1 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li>函数不要返回一个内部声明量的引用，都被销毁了，怎么反回？？不过可以 ‘直接返回这个对象’，实际会自动复制一个量来返回，返回后销毁<br>虚函数</li>
</ol>
<hr>
<p>基类中<font color="#00ffff">加了virtual还被重新定义过的函数</font><br>or<br>在派生类中重新定义虚函数时，<font color="#00ffff">可以不加关键字virtual</font>但是必须要和父类中的同名，同返回类型，同参数列表  </p>
<p>用法格式为：<br>virtual 函数返回类型 函数名（参数表） {函数体}；<br>实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。</p>
<ol>
<li>只有类的成员函数才能做虚函数   </li>
<li>静态成员函数是所有同类对象所共有的，不能作为虚函数    </li>
<li>全局函数不能做虚函数     </li>
<li>内联函数不能做虚函数      </li>
<li>构造函数不能定义为虚函数(因为在调用构造函数的时候对象还没有完全初始化)    </li>
<li>析构函数可以定义为虚函数（在父类及其派生类中都动态分配内存空间时，必须把父类的析构函数定义为虚函数，实现撤销对象时的多态性）   <font color="#00ffff">就是说，当过父亲了，就写virtual</font>。   </li>
<li>友元函数不能是虚函数，原因为第一条。  </li>
<li>纯虚函数 virtual void f1()=0有一个纯虚函数就是抽象基类，不能实例化，只能用做派生；</li>
<li>注意只有实现了纯虚函数具体化的派生类才不是ABC</li>
<li>要实现纯虚函数，注意子类的那个一定要一模一样</li>
<li>含有一个或多个纯虚函数的类称为抽象类</li>
<li>不要返回纯虚函数<br>原文链接：<a href="https://blog.csdn.net/github_33736971/article/details/51001310" target="_blank" rel="noopener">https://blog.csdn.net/github_33736971/article/details/51001310</a></li>
</ol>
<p>例题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A  &#123;   </span><br><span class="line"></span><br><span class="line">   virtual void func1()；   </span><br><span class="line"></span><br><span class="line">   void func2();   </span><br><span class="line"></span><br><span class="line">&#125; ；  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">class B: class A &#123;   </span><br><span class="line"></span><br><span class="line">   void func1() &#123;  </span><br><span class="line"></span><br><span class="line">        cout &lt; &lt; &quot;fun1 in class B&quot; &lt; &lt; endl;  </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    virtual void func2() &#123;  </span><br><span class="line"></span><br><span class="line">    cout &lt; &lt; &quot;fun2 in class B&quot; &lt; &lt; endl;  </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line"></span><br><span class="line">A、A中的func1和B中的func2都是虚函数</span><br><span class="line">B、A中的func1和B中的func2都不是虚函数. </span><br><span class="line">C、A中的func2是虚函数.，B中的func1不是虚函数. </span><br><span class="line">D、A中的func2不是虚函数，B中的func1是虚函数. </span><br><span class="line">【标准答案】A</span><br></pre></td></tr></table></figure>


<h2 id="坑爹老指针"><a href="#坑爹老指针" class="headerlink" title="坑爹老指针"></a>坑爹老指针</h2><ol>
<li><p>不初始化恶心人<br> 全局指针变量，申明的时候即使不初始化，系统会给你个默认的初始化值0x00000000(即NULL)<br>而对于局部指针变量则不会，会有警告对一个潜在的未初始化的局部指针变量的使用。<br>在VC++中，程序在Release模式下输出0x004080d0，而在Debug模式下输出0xcccccccc。很明显未初始化的指针指向的是一个随机的地址。如果对其执行写操作会怎样？那很有可能会直接导致程序崩溃。</p>
</li>
<li><p>C/C++ 中 NULL、’\0’、’0’ 、0、及空格的区别<br>1、NULL即空指针。在C中，NULL是指向0的指针，由 #define NULL ((void *)0)定义；在C++中，NULL就是0，由 #define NULL 0 定义。可参见 vs2013 的库文件 string.h。<br>2、’\0’ 是空字符常量，表示字符串的结束，ASCII码值为0。<br>3、’0’是字符0，ASCII码值为48。<br>4、0是数字0。<br>5、空格是可显示字符空格，ASCII 码值为32。<br>备注：<br>　　给指针置位为空指针时，应该使用 NULL；<br>　　给字符串添加结束标志时，应该使用 ‘\0’ 。  </p>
</li>
<li><p>&amp;tell[0]是一个内存块的地址，&amp;tell是一组的地址，所以tell+1会使地址值加一块，&amp;tell+1就是加一组（加整个数组）</p>
</li>
<li><p>使用a[10]声明数组叫做静态联编，new出来的叫做动态联编</p>
</li>
<li><p>short(<em>pas)[20]=&tell; pas指向这个short的数组.<br> short\</em>pas[20]=&tell;优先级规则让pas与[]先结合了，成了一个包含指针的数组。 </p>
</li>
<li><p>a[r][c]==*(*(a+r)+c)</p>
</li>
<li><p>当一个成员函数被调用时，该成员函数的 this指针 指向调用它的对象。就是说，可能会指向基类或派生类之类的，没有一定的指向</p>
</li>
<li><p><font color="#00ffff">类成员只要用char*,char[]就得new，string可以直接用，自动new了ok</font> </p>
</li>
<li><p>函数进去要char*，可以开一个char[50]直接cin，再甩进去
　　
　　</p>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>基类可以通过引用或指针调用派生类对象，但是不能用派生类方法。一般&amp;类挺方便</li>
<li>保护继承，基类的保护成员在派生类仍为保护成员</li>
<li>当一个派生类公有继承一个基类时，基类的public成员为派生类的public成员,但是派生类不能用基类的private</li>
<li>子类的指针和引用就不可以指向父类对象</li>
<li>接收一个参数的构造函数允许直接用=</li>
<li>this指针指向用来调用成员函数的对象</li>
<li>类里面不加inline 直接prototype就会自动内联</li>
<li>可以new一个类 classname * pclass= new classname(value);</li>
<li>有memory allocate 就要显式定义复制和赋值构造3</li>
<li>memory allocate的问题，自己管好自己的；基类有，基类搞，派生类新增的有，自己搞掉自己的，基类的等他自己搞； <font color="#00ffff">注意基类和派生类都DMA时，派生类必须用相应的基类方法来处理基类元素，显示搞都不会给你默认处理，自己调用</font></li>
<li>baseDMA::operator=(hs)</li>
<li>派生类成员可以访问基类的保护成员，但是不能访问基类的私有成员</li>
<li><font color="#00ffff">派生类加上新增的成员，要变化的函数，注意构造析构复制赋值就ok</font> </li>
<li>继承函数时，子类和父类 函数必须一模一样，这才能覆盖，不然可能只是隐藏或者另外一个函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">经典语法</span><br><span class="line">公有派生</span><br><span class="line">class b : public a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b::b(int x,double y,const string &amp; z) : a(y,z)</span><br><span class="line">&#123;</span><br><span class="line">	xx=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>覆盖与隐藏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只要基类在定义成员函数时已经声明了virtue关键字，在派生类实现的时候覆盖该函数时，virtue关键字可加可不加，不影响多态的实现。</span><br><span class="line">容易与隐藏混淆：</span><br><span class="line">隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</span><br><span class="line">1) 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。</span><br><span class="line">2) 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</span><br><span class="line">比如，在下面的程序中：</span><br><span class="line">#include &lt;iostream.h&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f(float x)&#123; cout &lt;&lt; &quot;Base::f(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">void g(float x)&#123; cout &lt;&lt; &quot;Base::g(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">void h(float x)&#123; cout &lt;&lt; &quot;Base::h(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derived : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f(float x)&#123; cout &lt;&lt; &quot;Derived::f(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">void g(int x)&#123; cout &lt;&lt; &quot;Derived::g(int) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">void h(float x)&#123; cout &lt;&lt; &quot;Derived::h(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">通过分析可得：</span><br><span class="line">1) 函数Derived::f(float)覆盖了Base::f(float)。</span><br><span class="line">2) 函数Derived::g(int)隐藏了Base::g(float)，注意，不是重载。</span><br><span class="line">3) 函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。</span><br><span class="line">看完前面的示例，可能大家还没明白隐藏与覆盖到底有什么区别，因为我们前面都是讲的表面现象，怎样的实现方式，属于要分析覆盖与隐藏在应用中到底有什么不同之处。在下面的程序中bp和dp指向同一地址，按理说运行结果应该是相同的，可事实并非如此。</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base *pb = &amp;d;</span><br><span class="line">Derived *pd = &amp;d;</span><br><span class="line">// Good : behavior depends solely on type of the object</span><br><span class="line">pb-&gt;f(3.14f); //运行结果: Derived::f(float) 3.14</span><br><span class="line">pd-&gt;f(3.14f); //运行结果: Derived::f(float) 3.14</span><br><span class="line">// Bad : behavior depends on type of the pointer</span><br><span class="line">pb-&gt;g(3.14f); //运行结果: Base::g(float) 3.14</span><br><span class="line">pd-&gt;g(3.14f); //运行结果: Derived::g(int) 3</span><br><span class="line">// Bad : behavior depends on type of the pointer</span><br><span class="line">pb-&gt;h(3.14f); //运行结果: Base::h(float) 3.14</span><br><span class="line">pd-&gt;h(3.14f); //运行结果: Derived::h(float) 3.14</span><br><span class="line">&#125;</span><br><span class="line">请大家注意，f()函数属于覆盖，而g()与h()属于隐藏。从上面的运行结果，我们可以注意到在覆盖中，用基类指针和派生类指针调用函数f()时，系统都是执行的派生类函数f()，而非基类的f()，这样实际上就是完成的“接口”功能。而在隐藏方式中，用基类指针和派生类指针调用函数f()时，系统会进行区分，基类指针调用时，系统执行基类的f()，而派生类指针调用时，系统“隐藏”了基类的f()，执行派生类的f()，这也就是“隐藏”的由来。</span><br></pre></td></tr></table></figure>

<p>自创习题，写一个food ABC，派生meat vegetable，再生成具体的实例， 使用DMA char*写归类 名称 特点，美味值函数， 美味值比较的函数，美味值排序函数，排序后打印函数，最好能用链表，统计每种食物数量，使用异常机制，判断输入正确性</p>
<h2 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef COORDIN_H_   (意指没定义coordin.h)</span><br><span class="line">#define COORDIN_H_</span><br><span class="line">\\代码块</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<ol>
<li>自定义头文件一般包含哪些东西<br>函数原型，#define和const定义的符号常量，结构，类以及模版的声明，内联函数</li>
<li>&lt;&gt;首先在储存标准头文件的文件系统中查找，””则是优先在当前工作目录或源代码目录查找</li>
<li>两个编译器的名称修饰方式很可能不同，所以链接编译模块时用同一个编译器</li>
<li>外部链接性（在其他文件能访问，全局变量），</li>
<li>内部链接性（只能这个文   件，‘全局’的static，叫做连接性为内部的静态持续变量）</li>
<li>无链接性，函数之类东西里面的</li>
<li>所有静态持续变量在整个程序执行期间都存在，不过记住它是internal的</li>
<li>注意，一般叫的全局变量，是静态的，external的</li>
<li>单定义规则，变量只能有一次定义，其他文件想用的话，extern int a;，不过， 这个extern可以省略</li>
<li>函数内的static只会在第一次调用时初始化一次，之后直接忽略。</li>
<li>static 都是internal的</li>
<li>const 全局变量 链接性为内部，不过C++会把const都以另外的方式整过去了 318 </li>
<li>默认函数的储存持续性为静态（程序运行过程中一直存在），链接性为external，不过可以用static限定</li>
<li>名称空间是全局的，也可以位于另一个名称空间中，但是不能位于代码块中，这意味着名称空间是external的</li>
</ol>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><ol>
<li>运算符重载之后，优先级，结合性和操作数都不变。</li>
<li>使用成员函数和友元函数的函数操作数不一样，一般友元函数会多一个</li>
<li>函数重载时将类型和类型引用视为同一个特征标，会出错   </li>
<li>函数重载时，必须改变参数表（特征标），改变返回类型没有用。</li>
<li>Time operator+(const Time &amp; a) const ,外面的const是整个函数的</li>
<li>友元函数重载单目运算符时打个空括号</li>
<li>重载&lt;&lt; &gt;&gt;时，打了friend ostream &amp; operator&lt;&lt;(ostream &amp; os ,const classname &amp; a)，之后只管把os当cout用，retrun os 就可以了;记住ostream不能加const，istream不能加引用</li>
</ol>
<h2 id="蛋疼字符串"><a href="#蛋疼字符串" class="headerlink" title="蛋疼字符串"></a>蛋疼字符串</h2><p>1 get &amp; getline</p>
<p>注意string的getline不一样，是getline(cin,str)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line"></span><br><span class="line">//getline 用 换行符来确定行尾，但是不储存换行符，而把它替换为空字符\0</span><br><span class="line">//cin.get();单独读取一个缓冲区的字符，可能只读取一个换行符而终止。 </span><br><span class="line">//这个问题可以用cin.ignore来解决</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char a[20];</span><br><span class="line">    char b[20];</span><br><span class="line">    std::cin.getline(a,10);</span><br><span class="line">    std::cin.get(b,20);//get保留换行符,一般别用这个</span><br><span class="line">    //两个同时有只会操作一个？？？</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;a&lt;&lt;std::endl;//10 ge</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;b&lt;&lt;&quot;sdsdsd&quot;;//输出19个字符</span><br><span class="line">    //cin 1234567890123</span><br><span class="line">    //cout 123456789</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展：<br>EOF(End Of File)<br>1.表示文件结束符（end of file）。<br>2.在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。<br>3.EOF 的值通常为 -1，在文本文件中，数据都是以字符的ASCII代码值的形式存放。ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。<br>4.C语言中，EOF常被作为文件结束的标志。还有很多文件处理函数处错误后的返回值也是EOF，因此常被用来判断调用一个函数是否成功。<br>5.C语言中,EOF即文档的结尾.但是,当你写一个小程序,并以EOF作为判断条件时,就无法输入文档的结尾了,只能人工输入一个,这个人工输入的文档结尾就是Ctrl+Z.(Ctrl+Z的值是-1，可以尝试将EOF替换成-1)<br>6.示例：<br>while(scanf(“%d”,&amp;n)!=EOF)；//注意：scanf函数有返回值，详见《scanf函数》。<br>while(getchar()!=EOF);//getchar函数也有返回值，格式错误返回-1.        </p>
<p>原文链接：<a href="https://blog.csdn.net/u011572481/article/details/78507411" target="_blank" rel="noopener">https://blog.csdn.net/u011572481/article/details/78507411</a></p>
<h1 id="经典笔试题目"><a href="#经典笔试题目" class="headerlink" title="经典笔试题目"></a>经典笔试题目</h1><p><a href="http://www.doc88.com/p-7754827488866.html" target="_blank" rel="noopener">http://www.doc88.com/p-7754827488866.html</a></p>
<p>1.、C 和 C++ 中 struct 有什么区别？  </p>
<table>
<thead>
<tr>
<th align="left"></th>
<th>Protection行为</th>
<th align="center">能否定义函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">C</td>
<td>无</td>
<td align="center">否，可有函数指针</td>
</tr>
<tr>
<td align="left">C++</td>
<td>有</td>
<td align="center">可以，默认public</td>
</tr>
</tbody></table>
<p>2、C++中的 struct 和 class 有什么区别？</p>
<p>【参考答案】从语法上讲，class和struct做类型定义时只有两点区别：<br>（一）默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理；<br>（二）成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。 除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。</p>
<p>3、 C和C++有什么不同?</p>
<p>【参考答案】<br>从机制上：C是面向过程的（但C也可以编写面向对象的程序）；C++是面向对象的，提供了类。但是，C++编写面向对象的程序比C容易。<br>从适用的方向：C适合要求代码体积小的，效率高的场合，如嵌入式；C++适合更上层的，复杂的; llinux核心大部分是C写的，因为它是系统软件，效率要求极高。<br>从名称上也可以看出，C++比C多了+，说明C++是C的超集；那为什么不叫C+而叫C++呢，是因为C++比C来说扩充的东西太多了，所以就在C后面放上两个+；于是就成了C++。<br>C语言是结构化编程语言，C++是面向对象编程语言。 C++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。</p>
<p>4、int id[sizeof(unsigned long)]; 这个对吗？为什么？<br>【标准答案】正确 这个 sizeof是编译时运算符，编译时就确定了 可以看成和机器有关的常量。</p>
<p>5、某文件中定义的静态全局变量(或称静态外部变量)其作用域是 () ?</p>
<p>A.只限某个函数  B.本文件<br>C.跨文件 D.不限制作用域<br>【参考答案】B。静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。<br>由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>
<p>6、C++函数中值的传递方式有哪几种？</p>
<p>【标准答案】C++函数的三种传递方式为：值传递、指针传递和引用传递。</p>
<p>7、对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现？</p>
<p>【标准答案】C用宏定义，C++用 inline</p>
<p>8、引用与指针有什么区别？</p>
<p>【参考答案】  </p>
<p>1) 引用必须被初始化，指针不必（最好写个null）。<br>2) 引用初始化以后不能被改变，指针可以改变所指的对象。<br>3) 不存在指向空值的引用，但是存在指向空值的指针   </p>
<p>9、C++中 virtual 与 inline 的含义分别是什么？</p>
<p>【参考答案】<br>在基类成员函数的声明前加上virtual关键字，意味着将该成员函数声明为虚函数。<br>inline与函数的定义体放在一起，使该函数称为内联。inline是一种用于实现的关键字，而不是用于声明的关键字。<br> 虚函数的特点；<br>如果希望派生类能够重新定义基类的方法，则在基类中将该方法定义为虚方法，这样可以启用动态联编。</p>
<p> 内联函数的特点；<br>使用内联函数的目的是为了提高函数的运行效率。<br>内联函数体的代码不能过长，因为内联函数省去<font color="#00ffff">调用函数的时间</font>是以代码膨胀为代价的。<br>内联函数不能包含循环语句，因为执行循环语句要比调用函数的开销大。   </p>
<p>10、 const  与 #define 的比较 ，const有什么优点?  </p>
<p>【参考答案】<br>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。<br>  而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。<br>（2）有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</p>
<p>11、有了 malloc/free 为什么还要 new/delete  ？</p>
<p>【参考答案】<br>malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。<br>由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。<br>因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。<br><font color="#00ffff">注意 new/delete 不是库函数。</font>     </p>
<p>12、C++是不是类型安全的？</p>
<p>【参考答案】不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。</p>
<p>13、<font color="#00ffff">const 符号常量；</font> </p>
<p>(1)const char *p      const 修饰 char *p  ，即指针指向的对象不能改变。<br>(2)char const <em>p       等同const char \</em>p ， 没有const *的运算，只能const一个char了，但是可以理解为const一个*p，即指针指向的对象不变。<br>(3)char * const p      const修饰指针，指针的指向不能改变。<br>说明上面三种描述的区别；  </p>
<p>【参考答案】<br>(1) p是一个指向const char的指针，p是可以改变指向的，但是p指向的值是不能改变的;<br>(2) p指向的恰好是一个指向const的char的普通指针；<br>(3) p是一个指针，这个指针是指向char的const指针。<br>(1)和(2)的定义是一样的。   </p>
<p>14、用C++写个程序，如何判断一个操作系统是16位还是32位的？</p>
<p>【标准答案】<br>定义一个指针p，打印出sizeof(p),如果节后是4，则表示该操作系统是32位，打印结果是2，表示是16位。</p>
<p>15、识别函数或指针</p>
<p>void * ( * (*fp1)(int))[10];<br>float (*(* fp2)(int,int,int))(int);<br>int (* ( * fp3)())[10]();<br>分别表示什么意思？</p>
<p>【标准答案】<br>1、void * ( * (*fp1)(int))[10];  fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，<br>这个数组有10个元素，每个元素是一个void*型指针。<br>2、float (*(* fp2)(int,int,int))(int);  fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，<br>这个函数的参数为int型，函数的返回值是float型。<br>3、int (* ( * fp3)())[10]();  fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，<br>这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。   </p>
<p>16、多态类中的虚函数表是 Compile-Time，还是 Run-Time 时建立的？</p>
<p>【标准答案】<br>虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.而对象的隐藏成员–虚拟函数表指针是<br>在运行期–也就是构造函数被调用时进行初始化的,这是实现多态的关键。   </p>
<p>17、错误的转义字符是？<br>A、’\091’<br>B、’\‘<br>C、’\0’ D.’&#39;‘<br>【标准答案】A</p>
<p>17、float a,b,c , 问等式 (a+b)+c==(b+a)+c 和 (a+b)+c==(a+c)+b 能否成立？</p>
<p>【参考答案】<br>两者都不行。在比较float或double时，不能简单地比较。由于计算误差，相等的概率很低。应判断两数之差是否落在区间（-e,e)内。<br>这个e应比浮点数的精度大一个数量级。</p>
<p>18、Heap 与 Stack 的差别</p>
<p>【参考答案】<br>Heap是堆，stack是栈。 Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。<br>Stack空间有限，Heap是很大的自由存储区 C中的malloc函数分配的内存空间即在堆上（这个堆有点不同，叫他自由储存区）,C++中对应的是new操作符在堆。<br>程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行</p>
<p>19、In C++, what does “explicit” mean? what does “protected” mean? </p>
<p>【标准答案】<br>C++中的 explicit 关键字用来修饰类的构造函数，表明该构造函数是显式的，在某些情况下，我们要求类的使用者必须显示调用类的构造函数时就需要使用 explicit，反之默认类型转换可能会造成无法预期的问题。<br>protected 控制的是一个函数对一个类的成员（包括成员变量及成员方法）的访问权限。protected成员只有该类的成员函数及其派生类的成员函数可以访问。</p>
<p>20、为什么需要使用堆，使用堆空间的原因？</p>
<p>【参考答案】<br>直到运行时才知道一个对象需要多少内存空间；不知道对象的生存期到底有多长。</p>
<p>21、<font color="#00ffff">const关键字？有哪些作用？</font> </p>
<p>【参考答案】<br>const关键字至少有下列n个作用：<br>（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；<br>（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；<br>（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。    </p>
<p>22、是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?</p>
<p>【参考答案】<br>virtual修饰符会被隐形继承的。virtual可加可不加。子类的空间里有父类的所有变量(static除外)。同一个函数只存在一个实体(inline除外)。子类覆盖它的函数不加virtual ,也能<br>实现多态。在子类的空间里，有父类的私有变量。私有变量不能直接访问。</p>
<p>23、面向对象的三个基本特征，并简单叙述之？</p>
<p>【参考答案】                                                                     </p>
<ol>
<li>封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected, public)                  </li>
<li>继承：广义的继承有三种实现形式：<br>实现继承（指使用基类的属性和方法而无需额外编码的能力）、<br>可视继承（子窗体使用父窗体的外观和实现代码）、<br>接口继承（仅使用属性和方法，实现滞后到子类实现）。<br>前两种（类继承）和后一种（对象组合=&gt;接口继承以及纯虚函数）构成了功能复用的两种方式。                                 </li>
<li>多态：是将父对象设置成为和一个或更多的与他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。<br>简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针</li>
</ol>
<p>24、<font color="#00ffff">重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别？</font> </p>
<p>【标准答案】<br>重载    同一名字空间  是指允许存在多个同名函数，而这些函数的参数表不同。<br>重定义/隐藏  不同名字空间 用于继承，派生类与基类的函数同名，屏蔽基类的函数<br>重写/覆盖 不同名字空间<br>用于继承，子类重新定义父类虚函数的方法    </p>
<p>25、多态的作用？</p>
<p>【参考答案】<br>主要是两个：</p>
<ol>
<li>隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；   </li>
<li>接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。   </li>
</ol>
<p>26、当一个类A 中没有声命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。</p>
<p>【标准答案】<br>sizeof(A) = 1；<br>编译器不允许一个类的大小为0，会为它分配1字节的内存。试想，若，不这样做，那2个类A的实例在内存中将会无法区分。</p>
<p> 一个空类对象的大小是1byte。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址。</p>
<p> 27、如果 ClassA 中定义并实现虚函数 int func(void)，ClassB 中也实现该函数，那么上述变量 a-&gt;func() 将调用哪个类里面的函数？如果 int func(void) 不是虚函数，情况又如何？为什么？</p>
<p>【参考答案】<br>第一问调用的是B的。第二问调用A的。<br>虚函数的一个典型应用，虚函数只能借助于指针或者引用来达到多态的效果。</p>
<p>28、 内联函数在编译时是否做参数类型检查</p>
<p>【参考答案】<br>内联函数要做参数类型检查,   这是内联函数跟宏相比的优势。                    </p>
<p>29、“new”in c++ is a？</p>
<p>A. library function like malloc in c<br>B. key word<br>C. operator<br>D. none of the above<br>【参考答案】C。<br>malloc是库函数，不在编译器控制范围之内；new是运算符，在编译器控制范围之内。<br>调用malloc时，从堆中申请内存；调用new时，从堆中申请内存并为内存调用构造函数。 </p>
<p>30、C++程序下列说法正确的有:</p>
<p>A、对调用的虚函数和模板类都进行迟后编译.<br>【标准答案】A</p>
<p>31、在 C++的一个类中声明一个 static 成员变量有没有用？</p>
<p>【参考答案】<br>在C++类的成员变量被声明为 static（称为静态成员变量），意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，<br>也就是说不管创建多少对象，static修饰的变量只占有一块内存。其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。static是加了访问控制的全局变量，不被继承。</p>
<p>32、函数模板与类模板有什么区别？</p>
<p>【参考答案】<br>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。</p>
<p>33、所有的运算符都能重载吗？</p>
<p>【参考答案】<br>不能被重载的运算符<br>在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。<br>（1）不能改变 C++内部数据类型（如 int,float 等）的运算符。<br>（2）不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。<br>（3）不能重载目前 C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级。<br>（4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。    </p>
<p>34、基类的析构函数不是虚函数，会带来什么问题？</p>
<p>【参考答案】<br>派生类的析构函数用不上，会造成资源的泄漏。</p>
<p>35、main 函数执行以前，还会执行什么代码？</p>
<p>【参考答案】<br>全局对象的构造函数会在main 函数之前执行。</p>
<p>36、<font color="#00ffff">下面两种if语句判断方式。请问哪种写法更好？为什么？   </font> </p>
<p>int n;<br>if (n == 10) // 第一种判断方式<br>if (10 == n) // 第二种判断方式<br>【参考答案】<br>这是一个风格问题，第二种方式如果少了个=号,编译时就会报错,减少了出错的可能行,可以检测出是否少了=。   </p>
<p>37、写出运行结果：</p>
<p>{</p>
<pre><code>// test1  char str[] = &quot;world&quot;;

 cout &lt;&lt; sizeof(str) &lt;&lt; &quot;: &quot;;

char *p = str;

cout &lt;&lt; sizeof(p) &lt;&lt; &quot;: &quot;;

char i = 10;

cout &lt;&lt; sizeof(i) &lt;&lt; &quot;: &quot;;

void *pp = malloc(10);

 cout &lt;&lt; sizeof(pp) &lt;&lt; endl;</code></pre><p>}</p>
<p>复制代码<br>【标准答案】6：4：1：4</p>
<p>38、int i = 5, b = 7; cout &lt;&lt; (i+++b) &lt;&lt;endl; 不用调试，请说出，以上代码在gcc编译过后的执行结果！</p>
<p>【标准答案】结果是12。i++左结合了</p>
<p>39、写出打印结果<br>unsigned short array[]={1,2,3,4,5,6,7};<br>int i = 3;<br>*(array + i) =  ？</p>
<p>【标准答案】4</p>
<p>40、字符指针、浮点数指针、以及函数指针这三种类型的变量哪个占用的内存最大？为什么？</p>
<p>【参考答案】<br>指针变量也占用内存单元，而且所有指针变量占用内存单元的数量都是相同的。<br>就是说，不管是指向何种对象的指针变量，它们占用内存的字节数都是一样的，并且要足够把程序中所能用到的最大地址表示出来（通常是一个机器字长）。</p>
<p>41、<font color="#00ffff">char*的问题</font> </p>
<p>char str1[]       = “abc”;  </p>
<p>char str2[]       = “abc”;  </p>
<p>const char str3[] = “abc”;   </p>
<p>const char str4[] = “abc”;   </p>
<p>const char* str5  = “abc”;  </p>
<p>const char* str6  = “abc”;  </p>
<p>cout &lt;&lt; boolalpha &lt;&lt; ( str1==str2 ) &lt;&lt; endl; // 输出什么？  </p>
<p>cout &lt;&lt; boolalpha &lt;&lt; ( str3==str4 ) &lt;&lt; endl; // 输出什么？  </p>
<p>cout &lt;&lt; boolalpha &lt;&lt; ( str5==str6 ) &lt;&lt; endl; // 输出什么？  </p>
<p>复制代码</p>
<p>【参考答案】<br>分别输出 false,false,true。<br>str1和str2都是字符数组，每个都有其自己的存储区，它们的值则是各存储区首地址，不等；<br>str3和str4同上，只是按const语义，它们所指向的数据区不能修改。<br>str5和str6并非数组而是字符指针，并不分配存储区，其后的“abc”以常量形式存于静态数据区，而它们自己仅是指向该区首地址的指针，相等。</p>
<p>42、以下代码有什么问题？        </p>
<p>cout &lt;&lt; (true?1:”1”) &lt;&lt; endl;</p>
<p>复制代码<br>【参考答案】<br>三元表达式“？:”问号后面的两个操作数必须为同一类型。</p>
<p>43、以下代码能够编译通过吗，为什么？</p>
<p>unsigned int const size1 = 2;  </p>
<p>char str1[ size1 ];  </p>
<p>unsigned int temp = 0;  </p>
<p>cin &gt;&gt; temp;  </p>
<p>unsigned int const size2 = temp;  </p>
<p>char str2[ size2 ];</p>
<p>复制代码</p>
<p>【标准答案】<br>str2定义出错，size2非编译器期间常量，而数组定义要求长度必须为编译期常量。</p>
<p>44、<font color="#00ffff">写出判断ABCD四个表达式的是否正确, 若正确, 写出经过表达式中 a 的值。</font> </p>
<p>int a = 4;  </p>
<p>(A)、a += (a++);</p>
<p>(B)、a += (++a) ;  </p>
<p>(C)、(a++) += a;</p>
<p>(D)、(++a) += (a++);  </p>
<p>a = ?</p>
<p>复制代码</p>
<p>【参考答案】<br>C错误，左侧不是一个有效变量，不能赋值，可改为 (++a) += a; 改后答案依次为 9,10,10,11</p>
<p>45、请你谈谈你是如何使用 return 语句的。</p>
<p>【参考答案】<br>（1）<font color="#00ffff">return 语句不可返回指向“栈内存”的“指针”或者“引用” ，因为该内存在函数体结束时被自动销毁。</font><br>（2）要搞清楚返回的究竟是“值”、“指针”还是“引用” 。<br>（3）如果函数返回值是一个对象，要考虑 return 语句的效率。  </p>
<p>46、<font color="#00ffff">const char*像string</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;    </span><br><span class="line">using namespace std;</span><br><span class="line">const char *str = &quot;vermeer&quot;;    </span><br><span class="line">int main()   </span><br><span class="line">&#123;</span><br><span class="line">    const char *pstr = str;     </span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*str&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&amp;str&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pstr&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*pstr&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&amp;pstr&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>47、求结果</p>
<p>int a,b;<br>b!=0;<br>a-a/b*b=?     a被b除的余数部分.  </p>
<p>48、<font color="#00ffff">求结果</font>.<br>int a=5,b=6,c=7;<br>cout&lt;&lt;((a+b)&lt;c&amp;&amp;b!=c)&lt;&lt;”,”&lt;&lt;((a+b)&lt;c,b=c).<br>0,7</p>
<p>49、内存提前分配</p>
<p>int x[10]={0,2,4};<br>    int k=sizeof(x);<br>    cout&lt;&lt;k&lt;&lt;endl;<br>    40</p>
<p>50、二维数组地址<br>int a[3][4],*p=a[0],访问a[i][j].  </p>
<ol>
<li>*(*(a+i)+j)</li>
<li>*(a[i]+j)</li>
<li>p[4*i+j]</li>
</ol>
<p>52、求值<br>int i=5;int f=15;<br>if(i=0) f-=5;<br>i=0 f=15</p>
<p>53、<font color="#00ffff">static求值</font> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int fun()</span><br><span class="line">&#123;</span><br><span class="line">	static int d2=0,d1=1;</span><br><span class="line">	int t=d2+d1;</span><br><span class="line">	d1=d2;</span><br><span class="line">	d2=t;</span><br><span class="line">	return d2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;6;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;fun()&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">1 1 2 3 5 8</span><br></pre></td></tr></table></figure>

<p>54、负数取模<br>int a = -8;<br>cout&lt;&lt;a%3&lt;&lt;endl;<br>//.  -2.  </p>
<p>55.++ –</p>
<p>“++””–”都为单目运算符</p>
<p>作为运算符来说”++””–”的优先级较高，高于所有算数运算符和逻辑运算符，但是使用这两个运算符时要注意它们的运算对象只能是变量，不能是其他表达式</p>
<p>例:(i+j)++就是一个错误的表达式</p>
<p>56、<br>字符串处理库函数<br><cstring></cstring></p>
<p>1*    strcpy(s1, s2);</p>
<p>复制字符串 s2 到字符串 s1。</p>
<p>2*    strcat(s1, s2);</p>
<p>连接字符串 s2 到字符串 s1 的末尾。</p>
<p>3*    strlen(s1);</p>
<p>返回字符串 s1 的长度。</p>
<p>4    strcmp(s1, s2);</p>
<p>如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</p>
<p>5    strchr(s1, ch);</p>
<p>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</p>
<p>6    strstr(s1, s2);</p>
<p>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</p>
<p>原文链接：<a href="https://blog.csdn.net/qq_41978688/article/details/80800236" target="_blank" rel="noopener">https://blog.csdn.net/qq_41978688/article/details/80800236</a></p>
<p>57、new</p>
<p>&lt;指针&gt; = new &lt;类型&gt;</p>
<p>&lt;指针&gt; = new &lt;类型&gt;（&lt;初值&gt;）；//可以赋值</p>
<p>58、2.1关键字 inline</p>
<p>（1）在C++程序中，除了在函数体中含有循环、switch分支和复杂的嵌套的if语句的函数外，所有函数均可被说明为内联函数</p>
<p>【内联函数不包含循环语句】</p>
<p>（2）内联函数大多都是小函数，其函数体不宜过大，一般宜在1到5行之间。</p>
<p>（3）关键字inline与函数定义放在一起才能使函数成为内联，内联函数的定义必须出现在对该函数的调用之前。这是因为编译器在对函数调用语句进行代换时，必须事先知道代换该语句的代码是什么。不然即使在函数的声明和函数的定义处均加上关键字inline都不行。</p>
<p>（4）由于计算机的资源有限，使用内联函数虽然节省了程序运行的时间开销，但却增大了代码占用内存的空间开销。因此具体编程时，应仔细的权衡时间开销与空间开销之间的矛盾，以确定是否采用内联函数。</p>
<p>59、用const修饰的声明声明成员函数称为常成员函数</p>
<p>声明：&lt;类型标志符&gt;函数名（参数表）const；</p>
<p>说明：</p>
<ol>
<li><p>const是函数类型的一部分，在实现部分也要带该关键字。</p>
</li>
<li><p>const关键字可以用于对重载函数的区分。</p>
</li>
<li><p>常成员函数不能更新任何数据成员，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数和常数据成员。</p>
</li>
</ol>
<p>60、计算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char a=&apos;a&apos;;</span><br><span class="line">    char b=&apos;j&apos;;</span><br><span class="line">    float x;</span><br><span class="line">    x=(b-a)/(&apos;F&apos;-&apos;A&apos;);</span><br><span class="line">    cout&lt;&lt;x;        //1,注意这个很日，它右边算的时候都是int，直接当int算完给float</span><br><span class="line">    printf(&quot;%d\n&quot;,(int)(3.14*x));//3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>61、默认构造函数与new</p>
<p>用new申请某一个类的动态对象数组时，在该类中必须能够匹配到 <strong><strong>___</strong></strong>构造函数，否则应用程序会产生一个编译错误。<br>没有形参的或缺省参数</p>
<p>62、if else<br>为了避免可能出现的歧义，C++对if…else语句配对规则规定为：else总是与 <strong><strong>___</strong></strong>配对。与最近的if </p>
<p>63、overload 与 override<br>在C++中，定义重载函数时，应至少使重载函数的参数个数或参数类型 <strong><strong>___</strong></strong>；在基类和派生类中，成员函数的覆盖是指 <strong>____</strong>。<br>不同   派生类成员函数与在基类被覆盖的成员函数名、参数个数、参数类型和返回值类型均相同</p>
<p>64、 动态联编要满足两个条件，它们是 <strong><strong>___</strong></strong>、 <strong><strong>___</strong></strong>。 被调用的成员函数是虚函数 、 用指针或引用调用虚函数</p>
<p>65、在C++类中，const关键字可以修饰对象和成员函数，const对象不能 <strong><strong>___</strong></strong>，const成员函数不能 <strong><strong>___</strong></strong>。 被修改  修改类数据成员</p>
<p>66、 C++中没有输入输出语句，输入输出是通过 <strong><strong>___</strong></strong>实现的 输入输出库 </p>
<p>67、结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void main( )    &#123; </span><br><span class="line">   test array[2];  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> cout &lt;&lt; array[1].getint( )&lt;&lt; &quot; &quot; &lt;&lt; array[1].getfloat( ) &lt;&lt;endl;  &#125; </span><br><span class="line">结果： </span><br><span class="line"> Initalizing default  Initalizing default</span><br><span class="line">   0 0 </span><br><span class="line"> Desdtructor is active  Desdtructor is active</span><br><span class="line"> </span><br><span class="line"> cout必须一口气操作</span><br></pre></td></tr></table></figure>

<p>68、结果??????</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   #include &lt;stdio.h&gt;  </span><br><span class="line">    int a[ ]=&#123;1,3,5,7,9&#125;; </span><br><span class="line">  int *p[ ]=&#123;a,a+1,a+2,a+3,a+4&#125;; </span><br><span class="line">    void main( )   &#123; </span><br><span class="line">   printf(&quot;%d\t%d\t%d\n&quot;,a[4],*(a+2),*p[1]); </span><br><span class="line">   printf(&quot;%d\t%d\t%d\n&quot;,**(p+1)+a[2],*(p+4)-*(p+0),*(a+3)%a[4]); </span><br><span class="line">&#125;  </span><br><span class="line">结果： 9 5 3 8 4 7</span><br></pre></td></tr></table></figure>
<p>69、<br>． 若程序员没有定义拷贝构造函数，则编译器自动生成一个缺省的拷贝构造函数，它可能会产生什么问题？<br>解答要点：当对象含有指针数据成员，并用它初始化同类型的另一个对象时，缺省的拷贝构造函数只能将该对象的数据成员复制给另一个对象，而不能将该对象中指针所指向的内存单元也复制过去。这样，就可能出现同一内存单元释放两次，导致程序运行出错。</p>
<p>70、<br>3． 简述结构化的程序设计、面向对象的程序设计的基本思想。<br>解答要点：结构化的程序设计将数据和对数据的操作分离，程序是由一个个的函数组成的，面向对象的程序设计将数据和操作封装在一起，程序是由一个个对象组成的，对象之间通过接口进行通信，它能够较好地支持程序代码的复用。</p>
<p>原文链接：<a href="https://blog.csdn.net/qq_41978688/article/details/80800236" target="_blank" rel="noopener">https://blog.csdn.net/qq_41978688/article/details/80800236</a></p>
<p>from：<a href="https://blog.csdn.net/weixin_41168353/article/details/80083861" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41168353/article/details/80083861</a></p>
<h2 id="EX"><a href="#EX" class="headerlink" title="EX"></a>EX</h2><p>函数指针。<br>函数模版</p>
]]></content>
      <categories>
        <category>final exam</category>
      </categories>
      <tags>
        <tag>final exam</tag>
      </tags>
  </entry>
</search>
