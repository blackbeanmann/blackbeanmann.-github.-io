<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="BEAN HOUSE" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="链表，c字符串栈，继承，    名称空间，11章的vector看一看，转换函数,  自动类对象，概念，虚函数 递归 表达式求值，类型转换，运算符的优先级（基本的）和结合性 循环条件的顺序与副作用  switch（它的break加班u 家结果完全不同），break和continue概念用法 数组的几个初始化方法字符数组与字符串结构体new delete指针与数组的转换 函数缺省 必须默认构造函数th">
<meta name="keywords" content="final exam">
<meta property="og:type" content="article">
<meta property="og:title" content="大一计算机考试复习">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;22&#x2F;%E5%A4%A7%E4%B8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0&#x2F;index.html">
<meta property="og:site_name" content="BEAN HOUSE">
<meta property="og:description" content="链表，c字符串栈，继承，    名称空间，11章的vector看一看，转换函数,  自动类对象，概念，虚函数 递归 表达式求值，类型转换，运算符的优先级（基本的）和结合性 循环条件的顺序与副作用  switch（它的break加班u 家结果完全不同），break和continue概念用法 数组的几个初始化方法字符数组与字符串结构体new delete指针与数组的转换 函数缺省 必须默认构造函数th">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-12-26T14:18:57.788Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2019/11/22/%E5%A4%A7%E4%B8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>大一计算机考试复习 | BEAN HOUSE</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BEAN HOUSE</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/22/%E5%A4%A7%E4%B8%80%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%80%83%E8%AF%95%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LX">
      <meta itemprop="description" content="A student">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BEAN HOUSE">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          大一计算机考试复习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-22 08:41:45" itemprop="dateCreated datePublished" datetime="2019-11-22T08:41:45+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-26 22:18:57" itemprop="dateModified" datetime="2019-12-26T22:18:57+08:00">2019-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/final-exam/" itemprop="url" rel="index">
                    <span itemprop="name">final exam</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>链表，c字符串栈，继承，    名称空间，</strong>11章的vector看一看，转换函数,  自动类对象，<strong>概念，虚函数</strong></p>
<p>递归</p>
<p>表达式求值，类型转换，运算符的优先级（基本的）和结合性</p>
<p>循环条件的顺序与副作用  switch（它的break加班u 家结果完全不同），break和continue概念用法</p>
<p>数组的几个初始化方法<br>字符数组与字符串<br>结构体<br>new delete<br>指针与数组的转换</p>
<p>函数缺省</p>
<p>必须默认构造函数<br>this<br>运算符重载，通常返回一个值，不是一个引用</p>
<p>静态成员变量和静态成员函数<br>各个内存块存放什么</p>
<p>3种继承方式的区别</p>
<p>指针细节，指向一位数组的指针和指向int的指针</p>
<p>虚函数 多层 多态重点</p>
<p><a href="https://wenku.baidu.com/view/b9008bbdfd0a79563c1e72cc.html?sxts=1576906677424" target="_blank" rel="noopener">https://wenku.baidu.com/view/b9008bbdfd0a79563c1e72cc.html?sxts=1576906677424</a></p>
<p><a href="https://wenku.baidu.com/view/2718df6648d7c1c708a14579.html?sxts=1576906756881&amp;sxts=1576907248200" target="_blank" rel="noopener">https://wenku.baidu.com/view/2718df6648d7c1c708a14579.html?sxts=1576906756881&amp;sxts=1576907248200</a></p>
<p><a href="https://wenku.baidu.com/view/cca5d9f6ed3a87c24028915f804d2b160a4e864d.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/cca5d9f6ed3a87c24028915f804d2b160a4e864d.html</a><br>输入和输出<br>====<br>流操作算子：<a href="http://c.biancheng.net/view/275.html" target="_blank" rel="noopener">http://c.biancheng.net/view/275.html</a>   格式化输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n = 141;</span><br><span class="line">    //1) 分别以十六进制、十进制、八进制先后输出 n</span><br><span class="line">    cout &lt;&lt; &quot;1)&quot; &lt;&lt; hex &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; dec &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; oct &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    double x = 1234567.89, y = 12.34567;</span><br><span class="line">    //2)保留5位有效数字</span><br><span class="line">    cout &lt;&lt; &quot;2)&quot; &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; endl;</span><br><span class="line">    //3)保留小数点后面5位</span><br><span class="line">    cout &lt;&lt; &quot;3)&quot; &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    //4)科学计数法输出，且保留小数点后面5位</span><br><span class="line">    cout &lt;&lt; &quot;4)&quot; &lt;&lt; scientific &lt;&lt; setprecision(5) &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    //5)非负数显示正号，输出宽度为12字符，宽度不足则用 * 填补</span><br><span class="line">    cout &lt;&lt; &quot;5)&quot; &lt;&lt; showpos &lt;&lt; fixed &lt;&lt; setw(12) &lt;&lt; setfill(&apos;*&apos;) &lt;&lt; 12.1 &lt;&lt; endl;</span><br><span class="line">    //6)非负数不显示正号，输出宽度为12字符，宽度不足则右边用填充字符填充</span><br><span class="line">    cout &lt;&lt; &quot;6)&quot; &lt;&lt; noshowpos &lt;&lt; setw(12) &lt;&lt; left &lt;&lt; 12.1 &lt;&lt; endl;</span><br><span class="line">    //7)输出宽度为 12 字符，宽度不足则左边用填充字符填充</span><br><span class="line">    cout &lt;&lt; &quot;7)&quot; &lt;&lt; setw(12) &lt;&lt; right &lt;&lt; 12.1 &lt;&lt; endl;</span><br><span class="line">    //8)宽度不足时，负号和数值分列左右，中间用填充字符填充</span><br><span class="line">    cout &lt;&lt; &quot;8)&quot; &lt;&lt; setw(12) &lt;&lt; internal &lt;&lt; -12.1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; &quot;9)&quot; &lt;&lt; 12.1 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li>函数不要返回一个内部声明量的引用，都被销毁了，怎么反回？？不过可以 ‘直接返回这个对象’，实际会自动复制一个量来返回，返回后销毁<br>虚函数</li>
</ol>
<hr>
<p>基类中<font color="#00ffff">加了virtual还被重新定义过的函数</font><br>or<br>在派生类中重新定义虚函数时，<font color="#00ffff">可以不加关键字virtual</font>但是必须要和父类中的同名，同返回类型，同参数列表  </p>
<p>用法格式为：<br>virtual 函数返回类型 函数名（参数表） {函数体}；<br>实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。</p>
<ol>
<li>只有类的成员函数才能做虚函数   </li>
<li>静态成员函数是所有同类对象所共有的，不能作为虚函数    </li>
<li>全局函数不能做虚函数     </li>
<li>内联函数不能做虚函数      </li>
<li>构造函数不能定义为虚函数(因为在调用构造函数的时候对象还没有完全初始化)    </li>
<li>析构函数可以定义为虚函数（在父类及其派生类中都动态分配内存空间时，必须把父类的析构函数定义为虚函数，实现撤销对象时的多态性）   <font color="#00ffff">就是说，当过父亲了，就写virtual</font>。   </li>
<li>友元函数不能是虚函数，原因为第一条。  </li>
<li>纯虚函数 virtual void f1()=0有一个纯虚函数就是抽象基类，不能实例化，只能用做派生；</li>
<li>注意只有实现了纯虚函数具体化的派生类才不是ABC</li>
<li>要实现纯虚函数，注意子类的那个一定要一模一样</li>
<li>含有一个或多个纯虚函数的类称为抽象类</li>
<li>不要返回纯虚函数<br>原文链接：<a href="https://blog.csdn.net/github_33736971/article/details/51001310" target="_blank" rel="noopener">https://blog.csdn.net/github_33736971/article/details/51001310</a></li>
</ol>
<p>例题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class A  &#123;   </span><br><span class="line"></span><br><span class="line">   virtual void func1()；   </span><br><span class="line"></span><br><span class="line">   void func2();   </span><br><span class="line"></span><br><span class="line">&#125; ；  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">class B: class A &#123;   </span><br><span class="line"></span><br><span class="line">   void func1() &#123;  </span><br><span class="line"></span><br><span class="line">        cout &lt; &lt; &quot;fun1 in class B&quot; &lt; &lt; endl;  </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    virtual void func2() &#123;  </span><br><span class="line"></span><br><span class="line">    cout &lt; &lt; &quot;fun2 in class B&quot; &lt; &lt; endl;  </span><br><span class="line"></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line"></span><br><span class="line">A、A中的func1和B中的func2都是虚函数</span><br><span class="line">B、A中的func1和B中的func2都不是虚函数. </span><br><span class="line">C、A中的func2是虚函数.，B中的func1不是虚函数. </span><br><span class="line">D、A中的func2不是虚函数，B中的func1是虚函数. </span><br><span class="line">【标准答案】A</span><br></pre></td></tr></table></figure>


<h2 id="坑爹老指针"><a href="#坑爹老指针" class="headerlink" title="坑爹老指针"></a>坑爹老指针</h2><ol>
<li><p>不初始化恶心人<br> 全局指针变量，申明的时候即使不初始化，系统会给你个默认的初始化值0x00000000(即NULL)<br>而对于局部指针变量则不会，会有警告对一个潜在的未初始化的局部指针变量的使用。<br>在VC++中，程序在Release模式下输出0x004080d0，而在Debug模式下输出0xcccccccc。很明显未初始化的指针指向的是一个随机的地址。如果对其执行写操作会怎样？那很有可能会直接导致程序崩溃。</p>
</li>
<li><p>C/C++ 中 NULL、’\0’、’0’ 、0、及空格的区别<br>1、NULL即空指针。在C中，NULL是指向0的指针，由 #define NULL ((void *)0)定义；在C++中，NULL就是0，由 #define NULL 0 定义。可参见 vs2013 的库文件 string.h。<br>2、’\0’ 是空字符常量，表示字符串的结束，ASCII码值为0。<br>3、’0’是字符0，ASCII码值为48。<br>4、0是数字0。<br>5、空格是可显示字符空格，ASCII 码值为32。<br>备注：<br>　　给指针置位为空指针时，应该使用 NULL；<br>　　给字符串添加结束标志时，应该使用 ‘\0’ 。  </p>
</li>
<li><p>&amp;tell[0]是一个内存块的地址，&amp;tell是一组的地址，所以tell+1会使地址值加一块，&amp;tell+1就是加一组（加整个数组）</p>
</li>
<li><p>使用a[10]声明数组叫做静态联编，new出来的叫做动态联编</p>
</li>
<li><p>short(<em>pas)[20]=&tell; pas指向这个short的数组.<br> short\</em>pas[20]=&tell;优先级规则让pas与[]先结合了，成了一个包含指针的数组。 </p>
</li>
<li><p>a[r][c]==*(*(a+r)+c)</p>
</li>
<li><p>当一个成员函数被调用时，该成员函数的 this指针 指向调用它的对象。就是说，可能会指向基类或派生类之类的，没有一定的指向</p>
</li>
<li><p><font color="#00ffff">类成员只要用char*,char[]就得new，string可以直接用，自动new了ok</font> </p>
</li>
<li><p>函数进去要char*，可以开一个char[50]直接cin，再甩进去
　　
　　</p>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>基类可以通过引用或指针调用派生类对象，但是不能用派生类方法。一般&amp;类挺方便</li>
<li>保护继承，基类的保护成员在派生类仍为保护成员</li>
<li>当一个派生类公有继承一个基类时，基类的public成员为派生类的public成员,但是派生类不能用基类的private</li>
<li>子类的指针和引用就不可以指向父类对象</li>
<li>接收一个参数的构造函数允许直接用=</li>
<li>this指针指向用来调用成员函数的对象</li>
<li>类里面不加inline 直接prototype就会自动内联</li>
<li>可以new一个类 classname * pclass= new classname(value);</li>
<li>有memory allocate 就要显式定义复制和赋值构造3</li>
<li>memory allocate的问题，自己管好自己的；基类有，基类搞，派生类新增的有，自己搞掉自己的，基类的等他自己搞； <font color="#00ffff">注意基类和派生类都DMA时，派生类必须用相应的基类方法来处理基类元素，显示搞都不会给你默认处理，自己调用</font></li>
<li>baseDMA::operator=(hs)</li>
<li>派生类成员可以访问基类的保护成员，但是不能访问基类的私有成员</li>
<li><font color="#00ffff">派生类加上新增的成员，要变化的函数，注意构造析构复制赋值就ok</font> </li>
<li>继承函数时，子类和父类 函数必须一模一样，这才能覆盖，不然可能只是隐藏或者另外一个函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">经典语法</span><br><span class="line">公有派生</span><br><span class="line">class b : public a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b::b(int x,double y,const string &amp; z) : a(y,z)</span><br><span class="line">&#123;</span><br><span class="line">	xx=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>覆盖与隐藏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">只要基类在定义成员函数时已经声明了virtue关键字，在派生类实现的时候覆盖该函数时，virtue关键字可加可不加，不影响多态的实现。</span><br><span class="line">容易与隐藏混淆：</span><br><span class="line">隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下：</span><br><span class="line">1) 如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。</span><br><span class="line">2) 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。</span><br><span class="line">比如，在下面的程序中：</span><br><span class="line">#include &lt;iostream.h&gt;</span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f(float x)&#123; cout &lt;&lt; &quot;Base::f(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">void g(float x)&#123; cout &lt;&lt; &quot;Base::g(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">void h(float x)&#123; cout &lt;&lt; &quot;Base::h(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Derived : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void f(float x)&#123; cout &lt;&lt; &quot;Derived::f(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">void g(int x)&#123; cout &lt;&lt; &quot;Derived::g(int) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">void h(float x)&#123; cout &lt;&lt; &quot;Derived::h(float) &quot; &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">通过分析可得：</span><br><span class="line">1) 函数Derived::f(float)覆盖了Base::f(float)。</span><br><span class="line">2) 函数Derived::g(int)隐藏了Base::g(float)，注意，不是重载。</span><br><span class="line">3) 函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。</span><br><span class="line">看完前面的示例，可能大家还没明白隐藏与覆盖到底有什么区别，因为我们前面都是讲的表面现象，怎样的实现方式，属于要分析覆盖与隐藏在应用中到底有什么不同之处。在下面的程序中bp和dp指向同一地址，按理说运行结果应该是相同的，可事实并非如此。</span><br><span class="line">void main(void)</span><br><span class="line">&#123;</span><br><span class="line">Derived d;</span><br><span class="line">Base *pb = &amp;d;</span><br><span class="line">Derived *pd = &amp;d;</span><br><span class="line">// Good : behavior depends solely on type of the object</span><br><span class="line">pb-&gt;f(3.14f); //运行结果: Derived::f(float) 3.14</span><br><span class="line">pd-&gt;f(3.14f); //运行结果: Derived::f(float) 3.14</span><br><span class="line">// Bad : behavior depends on type of the pointer</span><br><span class="line">pb-&gt;g(3.14f); //运行结果: Base::g(float) 3.14</span><br><span class="line">pd-&gt;g(3.14f); //运行结果: Derived::g(int) 3</span><br><span class="line">// Bad : behavior depends on type of the pointer</span><br><span class="line">pb-&gt;h(3.14f); //运行结果: Base::h(float) 3.14</span><br><span class="line">pd-&gt;h(3.14f); //运行结果: Derived::h(float) 3.14</span><br><span class="line">&#125;</span><br><span class="line">请大家注意，f()函数属于覆盖，而g()与h()属于隐藏。从上面的运行结果，我们可以注意到在覆盖中，用基类指针和派生类指针调用函数f()时，系统都是执行的派生类函数f()，而非基类的f()，这样实际上就是完成的“接口”功能。而在隐藏方式中，用基类指针和派生类指针调用函数f()时，系统会进行区分，基类指针调用时，系统执行基类的f()，而派生类指针调用时，系统“隐藏”了基类的f()，执行派生类的f()，这也就是“隐藏”的由来。</span><br></pre></td></tr></table></figure>

<p>自创习题，写一个food ABC，派生meat vegetable，再生成具体的实例， 使用DMA char*写归类 名称 特点，美味值函数， 美味值比较的函数，美味值排序函数，排序后打印函数，最好能用链表，统计每种食物数量，使用异常机制，判断输入正确性</p>
<h2 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef COORDIN_H_   (意指没定义coordin.h)</span><br><span class="line">#define COORDIN_H_</span><br><span class="line">\\代码块</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<ol>
<li>自定义头文件一般包含哪些东西<br>函数原型，#define和const定义的符号常量，结构，类以及模版的声明，内联函数</li>
<li>&lt;&gt;首先在储存标准头文件的文件系统中查找，””则是优先在当前工作目录或源代码目录查找</li>
<li>两个编译器的名称修饰方式很可能不同，所以链接编译模块时用同一个编译器</li>
<li>外部链接性（在其他文件能访问，全局变量），</li>
<li>内部链接性（只能这个文   件，‘全局’的static，叫做连接性为内部的静态持续变量）</li>
<li>无链接性，函数之类东西里面的</li>
<li>所有静态持续变量在整个程序执行期间都存在，不过记住它是internal的</li>
<li>注意，一般叫的全局变量，是静态的，external的</li>
<li>单定义规则，变量只能有一次定义，其他文件想用的话，extern int a;，不过， 这个extern可以省略</li>
<li>函数内的static只会在第一次调用时初始化一次，之后直接忽略。</li>
<li>static 都是internal的</li>
<li>const 全局变量 链接性为内部，不过C++会把const都以另外的方式整过去了 318 </li>
<li>默认函数的储存持续性为静态（程序运行过程中一直存在），链接性为external，不过可以用static限定</li>
<li>名称空间是全局的，也可以位于另一个名称空间中，但是不能位于代码块中，这意味着名称空间是external的</li>
</ol>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><ol>
<li>运算符重载之后，优先级，结合性和操作数都不变。</li>
<li>使用成员函数和友元函数的函数操作数不一样，一般友元函数会多一个</li>
<li>函数重载时将类型和类型引用视为同一个特征标，会出错   </li>
<li>函数重载时，必须改变参数表（特征标），改变返回类型没有用。</li>
<li>Time operator+(const Time &amp; a) const ,外面的const是整个函数的</li>
<li>友元函数重载单目运算符时打个空括号</li>
<li>重载&lt;&lt; &gt;&gt;时，打了friend ostream &amp; operator&lt;&lt;(ostream &amp; os ,const classname &amp; a)，之后只管把os当cout用，retrun os 就可以了;记住ostream不能加const，istream不能加引用</li>
</ol>
<h2 id="蛋疼字符串"><a href="#蛋疼字符串" class="headerlink" title="蛋疼字符串"></a>蛋疼字符串</h2><p>1 get &amp; getline</p>
<p>注意string的getline不一样，是getline(cin,str)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt; </span><br><span class="line"></span><br><span class="line">//getline 用 换行符来确定行尾，但是不储存换行符，而把它替换为空字符\0</span><br><span class="line">//cin.get();单独读取一个缓冲区的字符，可能只读取一个换行符而终止。 </span><br><span class="line">//这个问题可以用cin.ignore来解决</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char a[20];</span><br><span class="line">    char b[20];</span><br><span class="line">    std::cin.getline(a,10);</span><br><span class="line">    std::cin.get(b,20);//get保留换行符,一般别用这个</span><br><span class="line">    //两个同时有只会操作一个？？？</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;a&lt;&lt;std::endl;//10 ge</span><br><span class="line">    std::cout&lt;&lt;std::endl;</span><br><span class="line">    std::cout&lt;&lt;b&lt;&lt;&quot;sdsdsd&quot;;//输出19个字符</span><br><span class="line">    //cin 1234567890123</span><br><span class="line">    //cout 123456789</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拓展：<br>EOF(End Of File)<br>1.表示文件结束符（end of file）。<br>2.在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。<br>3.EOF 的值通常为 -1，在文本文件中，数据都是以字符的ASCII代码值的形式存放。ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。<br>4.C语言中，EOF常被作为文件结束的标志。还有很多文件处理函数处错误后的返回值也是EOF，因此常被用来判断调用一个函数是否成功。<br>5.C语言中,EOF即文档的结尾.但是,当你写一个小程序,并以EOF作为判断条件时,就无法输入文档的结尾了,只能人工输入一个,这个人工输入的文档结尾就是Ctrl+Z.(Ctrl+Z的值是-1，可以尝试将EOF替换成-1)<br>6.示例：<br>while(scanf(“%d”,&amp;n)!=EOF)；//注意：scanf函数有返回值，详见《scanf函数》。<br>while(getchar()!=EOF);//getchar函数也有返回值，格式错误返回-1.        </p>
<p>原文链接：<a href="https://blog.csdn.net/u011572481/article/details/78507411" target="_blank" rel="noopener">https://blog.csdn.net/u011572481/article/details/78507411</a></p>
<h1 id="经典笔试题目"><a href="#经典笔试题目" class="headerlink" title="经典笔试题目"></a>经典笔试题目</h1><p><a href="http://www.doc88.com/p-7754827488866.html" target="_blank" rel="noopener">http://www.doc88.com/p-7754827488866.html</a></p>
<p>1.、C 和 C++ 中 struct 有什么区别？  </p>
<table>
<thead>
<tr>
<th align="left"></th>
<th>Protection行为</th>
<th align="center">能否定义函数</th>
</tr>
</thead>
<tbody><tr>
<td align="left">C</td>
<td>无</td>
<td align="center">否，可有函数指针</td>
</tr>
<tr>
<td align="left">C++</td>
<td>有</td>
<td align="center">可以，默认public</td>
</tr>
</tbody></table>
<p>2、C++中的 struct 和 class 有什么区别？</p>
<p>【参考答案】从语法上讲，class和struct做类型定义时只有两点区别：<br>（一）默认继承权限。如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理；<br>（二）成员的默认访问权限。class的成员默认是private权限，struct默认是public权限。 除了这两点，class和struct基本就是一个东西。语法上没有任何其它区别。</p>
<p>3、 C和C++有什么不同?</p>
<p>【参考答案】<br>从机制上：C是面向过程的（但C也可以编写面向对象的程序）；C++是面向对象的，提供了类。但是，C++编写面向对象的程序比C容易。<br>从适用的方向：C适合要求代码体积小的，效率高的场合，如嵌入式；C++适合更上层的，复杂的; llinux核心大部分是C写的，因为它是系统软件，效率要求极高。<br>从名称上也可以看出，C++比C多了+，说明C++是C的超集；那为什么不叫C+而叫C++呢，是因为C++比C来说扩充的东西太多了，所以就在C后面放上两个+；于是就成了C++。<br>C语言是结构化编程语言，C++是面向对象编程语言。 C++侧重于对象而不是过程，侧重于类的设计而不是逻辑的设计。</p>
<p>4、int id[sizeof(unsigned long)]; 这个对吗？为什么？<br>【标准答案】正确 这个 sizeof是编译时运算符，编译时就确定了 可以看成和机器有关的常量。</p>
<p>5、某文件中定义的静态全局变量(或称静态外部变量)其作用域是 () ?</p>
<p>A.只限某个函数  B.本文件<br>C.跨文件 D.不限制作用域<br>【参考答案】B。静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。<br>由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避免在其它源文件中引起错误。</p>
<p>6、C++函数中值的传递方式有哪几种？</p>
<p>【标准答案】C++函数的三种传递方式为：值传递、指针传递和引用传递。</p>
<p>7、对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现？</p>
<p>【标准答案】C用宏定义，C++用 inline</p>
<p>8、引用与指针有什么区别？</p>
<p>【参考答案】  </p>
<p>1) 引用必须被初始化，指针不必（最好写个null）。<br>2) 引用初始化以后不能被改变，指针可以改变所指的对象。<br>3) 不存在指向空值的引用，但是存在指向空值的指针   </p>
<p>9、C++中 virtual 与 inline 的含义分别是什么？</p>
<p>【参考答案】<br>在基类成员函数的声明前加上virtual关键字，意味着将该成员函数声明为虚函数。<br>inline与函数的定义体放在一起，使该函数称为内联。inline是一种用于实现的关键字，而不是用于声明的关键字。<br> 虚函数的特点；<br>如果希望派生类能够重新定义基类的方法，则在基类中将该方法定义为虚方法，这样可以启用动态联编。</p>
<p> 内联函数的特点；<br>使用内联函数的目的是为了提高函数的运行效率。<br>内联函数体的代码不能过长，因为内联函数省去<font color="#00ffff">调用函数的时间</font>是以代码膨胀为代价的。<br>内联函数不能包含循环语句，因为执行循环语句要比调用函数的开销大。   </p>
<p>10、 const  与 #define 的比较 ，const有什么优点?  </p>
<p>【参考答案】<br>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。<br>  而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。<br>（2）有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</p>
<p>11、有了 malloc/free 为什么还要 new/delete  ？</p>
<p>【参考答案】<br>malloc 与 free 是 C++/C 语言的标准库函数，new/delete 是 C++的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用 maloc/free 无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。<br>由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于 malloc/free。<br>因此 C++语言需要一个能完成动态内存分配和初始化工作的运算符 new，以及一个能完成清理与释放内存工作的运算符 delete。<br><font color="#00ffff">注意 new/delete 不是库函数。</font>     </p>
<p>12、C++是不是类型安全的？</p>
<p>【参考答案】不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。</p>
<p>13、<font color="#00ffff">const 符号常量；</font> </p>
<p>(1)const char *p      const 修饰 char *p  ，即指针指向的对象不能改变。<br>(2)char const <em>p       等同const char \</em>p ， 没有const *的运算，只能const一个char了，但是可以理解为const一个*p，即指针指向的对象不变。<br>(3)char * const p      const修饰指针，指针的指向不能改变。<br>说明上面三种描述的区别；  </p>
<p>【参考答案】<br>(1) p是一个指向const char的指针，p是可以改变指向的，但是p指向的值是不能改变的;<br>(2) p指向的恰好是一个指向const的char的普通指针；<br>(3) p是一个指针，这个指针是指向char的const指针。<br>(1)和(2)的定义是一样的。   </p>
<p>14、用C++写个程序，如何判断一个操作系统是16位还是32位的？</p>
<p>【标准答案】<br>定义一个指针p，打印出sizeof(p),如果节后是4，则表示该操作系统是32位，打印结果是2，表示是16位。</p>
<p>15、识别函数或指针</p>
<p>void * ( * (*fp1)(int))[10];<br>float (*(* fp2)(int,int,int))(int);<br>int (* ( * fp3)())[10]();<br>分别表示什么意思？</p>
<p>【标准答案】<br>1、void * ( * (*fp1)(int))[10];  fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，<br>这个数组有10个元素，每个元素是一个void*型指针。<br>2、float (*(* fp2)(int,int,int))(int);  fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，<br>这个函数的参数为int型，函数的返回值是float型。<br>3、int (* ( * fp3)())[10]();  fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，<br>这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。   </p>
<p>16、多态类中的虚函数表是 Compile-Time，还是 Run-Time 时建立的？</p>
<p>【标准答案】<br>虚拟函数表是在编译期就建立了,各个虚拟函数这时被组织成了一个虚拟函数的入口地址的数组.而对象的隐藏成员–虚拟函数表指针是<br>在运行期–也就是构造函数被调用时进行初始化的,这是实现多态的关键。   </p>
<p>17、错误的转义字符是？<br>A、’\091’<br>B、’\‘<br>C、’\0’ D.’&#39;‘<br>【标准答案】A</p>
<p>17、float a,b,c , 问等式 (a+b)+c==(b+a)+c 和 (a+b)+c==(a+c)+b 能否成立？</p>
<p>【参考答案】<br>两者都不行。在比较float或double时，不能简单地比较。由于计算误差，相等的概率很低。应判断两数之差是否落在区间（-e,e)内。<br>这个e应比浮点数的精度大一个数量级。</p>
<p>18、Heap 与 Stack 的差别</p>
<p>【参考答案】<br>Heap是堆，stack是栈。 Stack的空间由操作系统自动分配/释放，Heap上的空间手动分配/释放。<br>Stack空间有限，Heap是很大的自由存储区 C中的malloc函数分配的内存空间即在堆上（这个堆有点不同，叫他自由储存区）,C++中对应的是new操作符在堆。<br>程序在编译期对变量和函数分配内存都在栈上进行,且程序运行过程中函数调用时参数的传递也在栈上进行</p>
<p>19、In C++, what does “explicit” mean? what does “protected” mean? </p>
<p>【标准答案】<br>C++中的 explicit 关键字用来修饰类的构造函数，表明该构造函数是显式的，在某些情况下，我们要求类的使用者必须显示调用类的构造函数时就需要使用 explicit，反之默认类型转换可能会造成无法预期的问题。<br>protected 控制的是一个函数对一个类的成员（包括成员变量及成员方法）的访问权限。protected成员只有该类的成员函数及其派生类的成员函数可以访问。</p>
<p>20、为什么需要使用堆，使用堆空间的原因？</p>
<p>【参考答案】<br>直到运行时才知道一个对象需要多少内存空间；不知道对象的生存期到底有多长。</p>
<p>21、<font color="#00ffff">const关键字？有哪些作用？</font> </p>
<p>【参考答案】<br>const关键字至少有下列n个作用：<br>（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；<br>（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；<br>（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；<br>（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。    </p>
<p>22、是不是一个父类写了一个virtual 函数，如果子类覆盖它的函数不加virtual ,也能实现多态?</p>
<p>【参考答案】<br>virtual修饰符会被隐形继承的。virtual可加可不加。子类的空间里有父类的所有变量(static除外)。同一个函数只存在一个实体(inline除外)。子类覆盖它的函数不加virtual ,也能<br>实现多态。在子类的空间里，有父类的私有变量。私有变量不能直接访问。</p>
<p>23、面向对象的三个基本特征，并简单叙述之？</p>
<p>【参考答案】                                                                     </p>
<ol>
<li>封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected, public)                  </li>
<li>继承：广义的继承有三种实现形式：<br>实现继承（指使用基类的属性和方法而无需额外编码的能力）、<br>可视继承（子窗体使用父窗体的外观和实现代码）、<br>接口继承（仅使用属性和方法，实现滞后到子类实现）。<br>前两种（类继承）和后一种（对象组合=&gt;接口继承以及纯虚函数）构成了功能复用的两种方式。                                 </li>
<li>多态：是将父对象设置成为和一个或更多的与他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。<br>简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针</li>
</ol>
<p>24、<font color="#00ffff">重载（overload)、重写(override，有的书也叫做“覆盖”）、重定义（redefinition）的区别？</font> </p>
<p>【标准答案】<br>重载    同一名字空间  是指允许存在多个同名函数，而这些函数的参数表不同。<br>重定义/隐藏  不同名字空间 用于继承，派生类与基类的函数同名，屏蔽基类的函数<br>重写/覆盖 不同名字空间<br>用于继承，子类重新定义父类虚函数的方法    </p>
<p>25、多态的作用？</p>
<p>【参考答案】<br>主要是两个：</p>
<ol>
<li>隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；   </li>
<li>接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。   </li>
</ol>
<p>26、当一个类A 中没有声命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。</p>
<p>【标准答案】<br>sizeof(A) = 1；<br>编译器不允许一个类的大小为0，会为它分配1字节的内存。试想，若，不这样做，那2个类A的实例在内存中将会无法区分。</p>
<p> 一个空类对象的大小是1byte。这是被编译器安插进去的一个字节，这样就使得这个空类的两个实例得以在内存中配置独一无二的地址。</p>
<p> 27、如果 ClassA 中定义并实现虚函数 int func(void)，ClassB 中也实现该函数，那么上述变量 a-&gt;func() 将调用哪个类里面的函数？如果 int func(void) 不是虚函数，情况又如何？为什么？</p>
<p>【参考答案】<br>第一问调用的是B的。第二问调用A的。<br>虚函数的一个典型应用，虚函数只能借助于指针或者引用来达到多态的效果。</p>
<p>28、 内联函数在编译时是否做参数类型检查</p>
<p>【参考答案】<br>内联函数要做参数类型检查,   这是内联函数跟宏相比的优势。                    </p>
<p>29、“new”in c++ is a？</p>
<p>A. library function like malloc in c<br>B. key word<br>C. operator<br>D. none of the above<br>【参考答案】C。<br>malloc是库函数，不在编译器控制范围之内；new是运算符，在编译器控制范围之内。<br>调用malloc时，从堆中申请内存；调用new时，从堆中申请内存并为内存调用构造函数。 </p>
<p>30、C++程序下列说法正确的有:</p>
<p>A、对调用的虚函数和模板类都进行迟后编译.<br>【标准答案】A</p>
<p>31、在 C++的一个类中声明一个 static 成员变量有没有用？</p>
<p>【参考答案】<br>在C++类的成员变量被声明为 static（称为静态成员变量），意味着它为该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，<br>也就是说不管创建多少对象，static修饰的变量只占有一块内存。其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。static是加了访问控制的全局变量，不被继承。</p>
<p>32、函数模板与类模板有什么区别？</p>
<p>【参考答案】<br>函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显式地指定。</p>
<p>33、所有的运算符都能重载吗？</p>
<p>【参考答案】<br>不能被重载的运算符<br>在 C++运算符集合中，有一些运算符是不允许被重载的。这种限制是出于安全方面的考虑，可防止错误和混乱。<br>（1）不能改变 C++内部数据类型（如 int,float 等）的运算符。<br>（2）不能重载‘.’，因为‘.’在类中对任何成员都有意义，已经成为标准用法。<br>（3）不能重载目前 C++运算符集合中没有的符号，如#,@,$等。原因有两点，一是难以理解，二是难以确定优先级。<br>（4）对已经存在的运算符进行重载时，不能改变优先级规则，否则将引起混乱。    </p>
<p>34、基类的析构函数不是虚函数，会带来什么问题？</p>
<p>【参考答案】<br>派生类的析构函数用不上，会造成资源的泄漏。</p>
<p>35、main 函数执行以前，还会执行什么代码？</p>
<p>【参考答案】<br>全局对象的构造函数会在main 函数之前执行。</p>
<p>36、<font color="#00ffff">下面两种if语句判断方式。请问哪种写法更好？为什么？   </font> </p>
<p>int n;<br>if (n == 10) // 第一种判断方式<br>if (10 == n) // 第二种判断方式<br>【参考答案】<br>这是一个风格问题，第二种方式如果少了个=号,编译时就会报错,减少了出错的可能行,可以检测出是否少了=。   </p>
<p>37、写出运行结果：</p>
<p>{</p>
<pre><code>// test1  char str[] = &quot;world&quot;;

 cout &lt;&lt; sizeof(str) &lt;&lt; &quot;: &quot;;

char *p = str;

cout &lt;&lt; sizeof(p) &lt;&lt; &quot;: &quot;;

char i = 10;

cout &lt;&lt; sizeof(i) &lt;&lt; &quot;: &quot;;

void *pp = malloc(10);

 cout &lt;&lt; sizeof(pp) &lt;&lt; endl;</code></pre><p>}</p>
<p>复制代码<br>【标准答案】6：4：1：4</p>
<p>38、int i = 5, b = 7; cout &lt;&lt; (i+++b) &lt;&lt;endl; 不用调试，请说出，以上代码在gcc编译过后的执行结果！</p>
<p>【标准答案】结果是12。i++左结合了</p>
<p>39、写出打印结果<br>unsigned short array[]={1,2,3,4,5,6,7};<br>int i = 3;<br>*(array + i) =  ？</p>
<p>【标准答案】4</p>
<p>40、字符指针、浮点数指针、以及函数指针这三种类型的变量哪个占用的内存最大？为什么？</p>
<p>【参考答案】<br>指针变量也占用内存单元，而且所有指针变量占用内存单元的数量都是相同的。<br>就是说，不管是指向何种对象的指针变量，它们占用内存的字节数都是一样的，并且要足够把程序中所能用到的最大地址表示出来（通常是一个机器字长）。</p>
<p>41、<font color="#00ffff">char*的问题</font> </p>
<p>char str1[]       = “abc”;  </p>
<p>char str2[]       = “abc”;  </p>
<p>const char str3[] = “abc”;   </p>
<p>const char str4[] = “abc”;   </p>
<p>const char* str5  = “abc”;  </p>
<p>const char* str6  = “abc”;  </p>
<p>cout &lt;&lt; boolalpha &lt;&lt; ( str1==str2 ) &lt;&lt; endl; // 输出什么？  </p>
<p>cout &lt;&lt; boolalpha &lt;&lt; ( str3==str4 ) &lt;&lt; endl; // 输出什么？  </p>
<p>cout &lt;&lt; boolalpha &lt;&lt; ( str5==str6 ) &lt;&lt; endl; // 输出什么？  </p>
<p>复制代码</p>
<p>【参考答案】<br>分别输出 false,false,true。<br>str1和str2都是字符数组，每个都有其自己的存储区，它们的值则是各存储区首地址，不等；<br>str3和str4同上，只是按const语义，它们所指向的数据区不能修改。<br>str5和str6并非数组而是字符指针，并不分配存储区，其后的“abc”以常量形式存于静态数据区，而它们自己仅是指向该区首地址的指针，相等。</p>
<p>42、以下代码有什么问题？        </p>
<p>cout &lt;&lt; (true?1:”1”) &lt;&lt; endl;</p>
<p>复制代码<br>【参考答案】<br>三元表达式“？:”问号后面的两个操作数必须为同一类型。</p>
<p>43、以下代码能够编译通过吗，为什么？</p>
<p>unsigned int const size1 = 2;  </p>
<p>char str1[ size1 ];  </p>
<p>unsigned int temp = 0;  </p>
<p>cin &gt;&gt; temp;  </p>
<p>unsigned int const size2 = temp;  </p>
<p>char str2[ size2 ];</p>
<p>复制代码</p>
<p>【标准答案】<br>str2定义出错，size2非编译器期间常量，而数组定义要求长度必须为编译期常量。</p>
<p>44、<font color="#00ffff">写出判断ABCD四个表达式的是否正确, 若正确, 写出经过表达式中 a 的值。</font> </p>
<p>int a = 4;  </p>
<p>(A)、a += (a++);</p>
<p>(B)、a += (++a) ;  </p>
<p>(C)、(a++) += a;</p>
<p>(D)、(++a) += (a++);  </p>
<p>a = ?</p>
<p>复制代码</p>
<p>【参考答案】<br>C错误，左侧不是一个有效变量，不能赋值，可改为 (++a) += a; 改后答案依次为 9,10,10,11</p>
<p>45、请你谈谈你是如何使用 return 语句的。</p>
<p>【参考答案】<br>（1）<font color="#00ffff">return 语句不可返回指向“栈内存”的“指针”或者“引用” ，因为该内存在函数体结束时被自动销毁。</font><br>（2）要搞清楚返回的究竟是“值”、“指针”还是“引用” 。<br>（3）如果函数返回值是一个对象，要考虑 return 语句的效率。  </p>
<p>46、<font color="#00ffff">const char*像string</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;    </span><br><span class="line">using namespace std;</span><br><span class="line">const char *str = &quot;vermeer&quot;;    </span><br><span class="line">int main()   </span><br><span class="line">&#123;</span><br><span class="line">    const char *pstr = str;     </span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*str&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&amp;str&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;pstr&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*pstr&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;&amp;pstr&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>47、求结果</p>
<p>int a,b;<br>b!=0;<br>a-a/b*b=?     a被b除的余数部分.  </p>
<p>48、<font color="#00ffff">求结果</font>.<br>int a=5,b=6,c=7;<br>cout&lt;&lt;((a+b)&lt;c&amp;&amp;b!=c)&lt;&lt;”,”&lt;&lt;((a+b)&lt;c,b=c).<br>0,7</p>
<p>49、内存提前分配</p>
<p>int x[10]={0,2,4};<br>    int k=sizeof(x);<br>    cout&lt;&lt;k&lt;&lt;endl;<br>    40</p>
<p>50、二维数组地址<br>int a[3][4],*p=a[0],访问a[i][j].  </p>
<ol>
<li>*(*(a+i)+j)</li>
<li>*(a[i]+j)</li>
<li>p[4*i+j]</li>
</ol>
<p>52、求值<br>int i=5;int f=15;<br>if(i=0) f-=5;<br>i=0 f=15</p>
<p>53、<font color="#00ffff">static求值</font> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int fun()</span><br><span class="line">&#123;</span><br><span class="line">	static int d2=0,d1=1;</span><br><span class="line">	int t=d2+d1;</span><br><span class="line">	d1=d2;</span><br><span class="line">	d2=t;</span><br><span class="line">	return d2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	for(int i=0;i&lt;6;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;fun()&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">1 1 2 3 5 8</span><br></pre></td></tr></table></figure>

<p>54、负数取模<br>int a = -8;<br>cout&lt;&lt;a%3&lt;&lt;endl;<br>//.  -2.  </p>
<p>55.++ –</p>
<p>“++””–”都为单目运算符</p>
<p>作为运算符来说”++””–”的优先级较高，高于所有算数运算符和逻辑运算符，但是使用这两个运算符时要注意它们的运算对象只能是变量，不能是其他表达式</p>
<p>例:(i+j)++就是一个错误的表达式</p>
<p>56、<br>字符串处理库函数<br><cstring></cstring></p>
<p>1*    strcpy(s1, s2);</p>
<p>复制字符串 s2 到字符串 s1。</p>
<p>2*    strcat(s1, s2);</p>
<p>连接字符串 s2 到字符串 s1 的末尾。</p>
<p>3*    strlen(s1);</p>
<p>返回字符串 s1 的长度。</p>
<p>4    strcmp(s1, s2);</p>
<p>如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</p>
<p>5    strchr(s1, ch);</p>
<p>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</p>
<p>6    strstr(s1, s2);</p>
<p>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</p>
<p>原文链接：<a href="https://blog.csdn.net/qq_41978688/article/details/80800236" target="_blank" rel="noopener">https://blog.csdn.net/qq_41978688/article/details/80800236</a></p>
<p>57、new</p>
<p>&lt;指针&gt; = new &lt;类型&gt;</p>
<p>&lt;指针&gt; = new &lt;类型&gt;（&lt;初值&gt;）；//可以赋值</p>
<p>58、2.1关键字 inline</p>
<p>（1）在C++程序中，除了在函数体中含有循环、switch分支和复杂的嵌套的if语句的函数外，所有函数均可被说明为内联函数</p>
<p>【内联函数不包含循环语句】</p>
<p>（2）内联函数大多都是小函数，其函数体不宜过大，一般宜在1到5行之间。</p>
<p>（3）关键字inline与函数定义放在一起才能使函数成为内联，内联函数的定义必须出现在对该函数的调用之前。这是因为编译器在对函数调用语句进行代换时，必须事先知道代换该语句的代码是什么。不然即使在函数的声明和函数的定义处均加上关键字inline都不行。</p>
<p>（4）由于计算机的资源有限，使用内联函数虽然节省了程序运行的时间开销，但却增大了代码占用内存的空间开销。因此具体编程时，应仔细的权衡时间开销与空间开销之间的矛盾，以确定是否采用内联函数。</p>
<p>59、用const修饰的声明声明成员函数称为常成员函数</p>
<p>声明：&lt;类型标志符&gt;函数名（参数表）const；</p>
<p>说明：</p>
<ol>
<li><p>const是函数类型的一部分，在实现部分也要带该关键字。</p>
</li>
<li><p>const关键字可以用于对重载函数的区分。</p>
</li>
<li><p>常成员函数不能更新任何数据成员，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数和常数据成员。</p>
</li>
</ol>
<p>60、计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char a=&apos;a&apos;;</span><br><span class="line">    char b=&apos;j&apos;;</span><br><span class="line">    float x;</span><br><span class="line">    x=(b-a)/(&apos;F&apos;-&apos;A&apos;);</span><br><span class="line">    cout&lt;&lt;x;        //1,注意这个很日，它右边算的时候都是int，直接当int算完给float</span><br><span class="line">    printf(&quot;%d\n&quot;,(int)(3.14*x));//3</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>61、默认构造函数与new</p>
<p>用new申请某一个类的动态对象数组时，在该类中必须能够匹配到 <strong><strong>___</strong></strong>构造函数，否则应用程序会产生一个编译错误。<br>没有形参的或缺省参数</p>
<p>62、if else<br>为了避免可能出现的歧义，C++对if…else语句配对规则规定为：else总是与 <strong><strong>___</strong></strong>配对。与最近的if </p>
<p>63、overload 与 override<br>在C++中，定义重载函数时，应至少使重载函数的参数个数或参数类型 <strong><strong>___</strong></strong>；在基类和派生类中，成员函数的覆盖是指 <strong>____</strong>。<br>不同   派生类成员函数与在基类被覆盖的成员函数名、参数个数、参数类型和返回值类型均相同</p>
<p>64、 动态联编要满足两个条件，它们是 <strong><strong>___</strong></strong>、 <strong><strong>___</strong></strong>。 被调用的成员函数是虚函数 、 用指针或引用调用虚函数</p>
<p>65、在C++类中，const关键字可以修饰对象和成员函数，const对象不能 <strong><strong>___</strong></strong>，const成员函数不能 <strong><strong>___</strong></strong>。 被修改  修改类数据成员</p>
<p>66、 C++中没有输入输出语句，输入输出是通过 <strong><strong>___</strong></strong>实现的 输入输出库 </p>
<p>67、结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void main( )    &#123; </span><br><span class="line">   test array[2];  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> cout &lt;&lt; array[1].getint( )&lt;&lt; &quot; &quot; &lt;&lt; array[1].getfloat( ) &lt;&lt;endl;  &#125; </span><br><span class="line">结果： </span><br><span class="line"> Initalizing default  Initalizing default</span><br><span class="line">   0 0 </span><br><span class="line"> Desdtructor is active  Desdtructor is active</span><br><span class="line"> </span><br><span class="line"> cout必须一口气操作</span><br></pre></td></tr></table></figure>

<p>68、结果??????</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   #include &lt;stdio.h&gt;  </span><br><span class="line">    int a[ ]=&#123;1,3,5,7,9&#125;; </span><br><span class="line">  int *p[ ]=&#123;a,a+1,a+2,a+3,a+4&#125;; </span><br><span class="line">    void main( )   &#123; </span><br><span class="line">   printf(&quot;%d\t%d\t%d\n&quot;,a[4],*(a+2),*p[1]); </span><br><span class="line">   printf(&quot;%d\t%d\t%d\n&quot;,**(p+1)+a[2],*(p+4)-*(p+0),*(a+3)%a[4]); </span><br><span class="line">&#125;  </span><br><span class="line">结果： 9 5 3 8 4 7</span><br></pre></td></tr></table></figure>
<p>69、<br>． 若程序员没有定义拷贝构造函数，则编译器自动生成一个缺省的拷贝构造函数，它可能会产生什么问题？<br>解答要点：当对象含有指针数据成员，并用它初始化同类型的另一个对象时，缺省的拷贝构造函数只能将该对象的数据成员复制给另一个对象，而不能将该对象中指针所指向的内存单元也复制过去。这样，就可能出现同一内存单元释放两次，导致程序运行出错。</p>
<p>70、<br>3． 简述结构化的程序设计、面向对象的程序设计的基本思想。<br>解答要点：结构化的程序设计将数据和对数据的操作分离，程序是由一个个的函数组成的，面向对象的程序设计将数据和操作封装在一起，程序是由一个个对象组成的，对象之间通过接口进行通信，它能够较好地支持程序代码的复用。</p>
<p>原文链接：<a href="https://blog.csdn.net/qq_41978688/article/details/80800236" target="_blank" rel="noopener">https://blog.csdn.net/qq_41978688/article/details/80800236</a></p>
<p>from：<a href="https://blog.csdn.net/weixin_41168353/article/details/80083861" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41168353/article/details/80083861</a></p>
<h2 id="EX"><a href="#EX" class="headerlink" title="EX"></a>EX</h2><p>函数指针。<br>函数模版</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/final-exam/" rel="tag"># final exam</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2019/11/22/python%20&%20regular%20expression/" rel="next" title="python & regular expression">
      python & regular expression <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">1.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#坑爹老指针"><span class="nav-number">1.1.</span> <span class="nav-text">坑爹老指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承"><span class="nav-number">1.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存模型和名称空间"><span class="nav-number">1.3.</span> <span class="nav-text">内存模型和名称空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载"><span class="nav-number">1.4.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#蛋疼字符串"><span class="nav-number">1.5.</span> <span class="nav-text">蛋疼字符串</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#经典笔试题目"><span class="nav-number">2.</span> <span class="nav-text">经典笔试题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#EX"><span class="nav-number">2.1.</span> <span class="nav-text">EX</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LX"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">LX</p>
  <div class="site-description" itemprop="description">A student</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=32098386&auto=1&height=66"></iframe>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LX</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>

<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas>
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script>
<script type="text/javascript" src="/js/src/fireworks.js"></script>

</html>

